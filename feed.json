{
    "version": "https://jsonfeed.org/version/1",
    "title": "hc‘s blog",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/04/19/4.18%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/",
            "url": "http://example.com/2023/04/19/4.18%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/",
            "title": "4.18算法记录",
            "date_published": "2023-04-19T01:56:03.756Z",
            "content_html": "<p>（开始为了秋招做一点记录吧，不然就摆了）</p>\n<p>1.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbGlua2VkLWxpc3QtZWxlbWVudHMv\"> 移除链表元素</span></p>\n<p>​\t给你一个链表的头节点  <code>head</code>  和一个整数  <code>val</code>  ，请你删除链表中所有满足  <code>Node.val == val</code>  的节点，并返回 <strong>新的头节点</strong> 。</p>\n<p><a href=\"https://imgtg.com/image/uicAL\"><img data-src=\"https://i.imgtg.com/2023/04/18/uicAL.png\" alt=\"uicAL.png\"></a></p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeElements</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        ListNode dummyNode = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummyNode.next = head;</span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        ListNode pre = dummyNode;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur.val == val) &#123;</span><br><span class=\"line\">                pre.next = cur.next;</span><br><span class=\"line\">                cur = pre.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                pre = pre.next;</span><br><span class=\"line\">                cur = cur.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummyNode.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//思考：</span></span><br><span class=\"line\"><span class=\"comment\">//题目不算难，但还是小费了点时间，因为对情况的模拟不到位，总是差不多就写了。下次一定要在脑子里想清楚在动笔！！</span></span><br></pre></td></tr></table></figure>\n<p>2.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZXNpZ24tbGlua2VkLWxpc3Qv\"> 设计链表</span></p>\n<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>\n<p>单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针 / 引用。</p>\n<p>如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。</p>\n<p>实现 MyLinkedList 类：</p>\n<ul>\n<li>MyLinkedList () 初始化 MyLinkedList 对象。</li>\n<li>int get (int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。</li>\n<li>void addAtHead (int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>\n<li>void addAtTail (int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。</li>\n<li>void addAtIndex (int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。</li>\n<li>void deleteAtIndex (int index) 如果下标有效，则删除链表中下标为 index 的节点。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入</span><br><span class=\"line\">[<span class=\"string\">&quot;MyLinkedList&quot;</span>, <span class=\"string\">&quot;addAtHead&quot;</span>, <span class=\"string\">&quot;addAtTail&quot;</span>, <span class=\"string\">&quot;addAtIndex&quot;</span>, <span class=\"string\">&quot;get&quot;</span>, <span class=\"string\">&quot;deleteAtIndex&quot;</span>, <span class=\"string\">&quot;get&quot;</span>]</span><br><span class=\"line\">[[], [<span class=\"number\">1</span>], [<span class=\"number\">3</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">1</span>], [<span class=\"number\">1</span>], [<span class=\"number\">1</span>]]</span><br><span class=\"line\">输出</span><br><span class=\"line\">[<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"number\">2</span>, <span class=\"keyword\">null</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">解释</span><br><span class=\"line\">MyLinkedList myLinkedList = <span class=\"keyword\">new</span> MyLinkedList();</span><br><span class=\"line\">myLinkedList.addAtHead(<span class=\"number\">1</span>);</span><br><span class=\"line\">myLinkedList.addAtTail(<span class=\"number\">3</span>);</span><br><span class=\"line\">myLinkedList.addAtIndex(<span class=\"number\">1</span>, <span class=\"number\">2</span>);    <span class=\"comment\">// 链表变为 1-&gt;2-&gt;3</span></span><br><span class=\"line\">myLinkedList.get(<span class=\"number\">1</span>);              <span class=\"comment\">// 返回 2</span></span><br><span class=\"line\">myLinkedList.deleteAtIndex(<span class=\"number\">1</span>);    <span class=\"comment\">// 现在，链表变为 1-&gt;3</span></span><br><span class=\"line\">myLinkedList.get(<span class=\"number\">1</span>);              <span class=\"comment\">// 返回 3</span></span><br></pre></td></tr></table></figure>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    int val;</span></span><br><span class=\"line\"><span class=\"comment\">//    ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\">//  ListNode()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    ListNode(int val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       this.val=val;</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//这个可以不写</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLinkedList</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyLinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index &lt; <span class=\"number\">0</span> || index &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode node = head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= index; i++) &#123;</span><br><span class=\"line\">            node = node.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addAtHead</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        addAtIndex(<span class=\"number\">0</span>, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addAtTail</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        addAtIndex(size, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addAtIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode cur = head.next;</span><br><span class=\"line\">        ListNode pre = head;</span><br><span class=\"line\">        ListNode node = <span class=\"keyword\">new</span> ListNode(val);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            pre = pre.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        pre.next = node;</span><br><span class=\"line\">        node.next = cur;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteAtIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index &lt; <span class=\"number\">0</span> || index &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode cur = head.next;</span><br><span class=\"line\">        ListNode pre = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            pre = pre.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        pre.next = cur.next;</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//题目的意思其实是根据单链表或者双链表来实现一个更强的链表。所以Listnode可以随便用，一开始没意识到这一点，所以有点无从下笔。其次，设置一个size和虚拟头节点也很关键！</span></span><br></pre></td></tr></table></figure>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/28/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F/",
            "url": "http://example.com/2022/08/28/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F/",
            "title": "Spring依赖注入有几种？各自有什么优缺点？",
            "date_published": "2022-08-28T06:02:50.667Z",
            "content_html": "<p>IoC 和 DI 是 Spring 中最重要的两个概念，其中 IoC 为控制反转的思想，而 DI 依赖注入是 IoC 的具体实现。</p>\n<hr>\n<h4 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\">#</a> 概述</h4>\n<p>在 Spring 中实现依赖注入的常见方式有以下 3 种：</p>\n<ol>\n<li><strong>属性注入（Field Injection）；</strong></li>\n<li><strong>Setter 注入（Setter Injection）；</strong></li>\n<li><strong>构造方法注入（Constructor Injection）。</strong></li>\n</ol>\n<h4 id=\"属性注入\"><a class=\"markdownIt-Anchor\" href=\"#属性注入\">#</a> 属性注入</h4>\n<p>属性注入是日常开发中使用最多的一种注入方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 属性对象</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">add</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userService.add(username, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h5>\n<p><strong>属性注入最大的优点就是实现简单、使用简单</strong>，只需要给变量上添加一个注解（@Autowired），就可以在不 new 对象的情况下，直接获得注入的对象了（这就是 DI 的功能和魅力所在），所以它的优点就是使用简单。</p>\n<h5 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点</h5>\n<p>属性注入虽然使用简单，但是也存在很多问题，甚至编译器 Idea 都会提醒你 “不建议使用此注入方式”，Idea 的提示信息如下：</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/10/Y8uCq.png\" alt=\"image-20220827130311145\"></p>\n<p>属性注入的缺点主要包含以下 3 个：</p>\n<ol>\n<li>功能性问题：无法注入一个不可变的对象（final 修饰的对象）；</li>\n<li>通用性问题：只能适应于 IoC 容器；</li>\n<li>设计原则问题：更容易违背单一设计原则。</li>\n</ol>\n<h4 id=\"setter注入\"><a class=\"markdownIt-Anchor\" href=\"#setter注入\">#</a> Setter 注入</h4>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Setter 注入</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserService</span><span class=\"params\">(UserService userService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userService = userService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">add</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userService.add(username, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"优点-2\"><a class=\"markdownIt-Anchor\" href=\"#优点-2\">#</a> 优点</h5>\n<p>完全符合单一职责的设计原则，因为每一个 Setter 只针对一个对象。</p>\n<h5 id=\"缺点-2\"><a class=\"markdownIt-Anchor\" href=\"#缺点-2\">#</a> 缺点</h5>\n<ol>\n<li>不能注入不可变对象（final 修饰的对象）；</li>\n<li>注入的对象可被修改。</li>\n</ol>\n<h4 id=\"构造方法注入\"><a class=\"markdownIt-Anchor\" href=\"#构造方法注入\">#</a> 构造方法注入</h4>\n<p><strong>构造方法注入是 Spring 官方从 4.x 之后推荐的注入方式</strong>，它的实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造方法注入</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">(UserService userService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userService = userService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">add</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userService.add(username, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，<strong>如果当前的类中只有一个构造方法，那么 @Autowired 也可以省略</strong>，所以以上代码还可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造方法注入</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">(UserService userService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userService = userService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">add</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userService.add(username, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"优点-3\"><a class=\"markdownIt-Anchor\" href=\"#优点-3\">#</a> 优点</h5>\n<ol>\n<li>可注入不可变对象；</li>\n<li>注入对象不会被修改；</li>\n<li>注入对象会被完全初始化；</li>\n<li>通用性更好。</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/28/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/",
            "url": "http://example.com/2022/08/28/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/",
            "title": "如何保证数据库和缓存双写一致性？",
            "date_published": "2022-08-28T06:02:50.658Z",
            "content_html": "<p> 数据库和缓存的双写数据一致性问题，是一个和开发语言无关的公共问题。尤其在高并发的场景下，这个问题变得更加严重。</p>\n<hr>\n<h4 id=\"常见方案\"><a href=\"#常见方案\" class=\"headerlink\" title=\"常见方案\"></a>常见方案</h4><p>通常情况下，我们使用缓存的目的主要是为了提升查询的性能。</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/09/Y9WKC.png\" alt=\"image-20220826232725235\"></p>\n<p>但是如果数据库中的某条数据，在放入缓存后又立马被更新了，那该如何更新缓存呢？</p>\n<p>目前有4种方案：</p>\n<ol>\n<li>先写缓存，再写数据库</li>\n<li>先写数据库，再写缓存</li>\n<li>先删缓存，再写数据库</li>\n<li>先写数据库，再删缓存</li>\n</ol>\n<h4 id=\"先写缓存，再写数据库\"><a href=\"#先写缓存，再写数据库\" class=\"headerlink\" title=\"先写缓存，再写数据库\"></a>先写缓存，再写数据库</h4><p>实际上这种方案不可取。</p>\n<p>例如用户在刚写完缓存后，网络出现了异常，导致写数据库失败了。那么缓存这种数据库不存在的”假数据“就没有意义了。</p>\n<h4 id=\"先写数据库，再写缓存\"><a href=\"#先写数据库，再写缓存\" class=\"headerlink\" title=\"先写数据库，再写缓存\"></a>先写数据库，再写缓存</h4><p>首先它可以避免之前的”假数据“问题，但是他有新的问题。</p>\n<h4 id=\"先删缓存，再写数据库\"><a href=\"#先删缓存，再写数据库\" class=\"headerlink\" title=\"先删缓存，再写数据库\"></a>先删缓存，再写数据库</h4><h4 id=\"先写数据库，再删缓存\"><a href=\"#先写数据库，再删缓存\" class=\"headerlink\" title=\"先写数据库，再删缓存\"></a>先写数据库，再删缓存</h4><p>推荐使用</p>\n<p>当然即使是这种方式还是存在着一定的问题，</p>\n<p>后续可以采用mq等方式来解决。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/28/%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%BB%80%E4%B9%88/",
            "url": "http://example.com/2022/08/28/%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%BB%80%E4%B9%88/",
            "title": "输入URL之后会执行什么",
            "date_published": "2022-08-28T06:02:50.653Z",
            "content_html": "<p> 在浏览器输入URL之后，它会执行以下几个流程：</p>\n<ol>\n<li>执行DNS域名解析；</li>\n<li>封装HTTP请求数据包；</li>\n<li>封装TCP请求数据包</li>\n<li>建立TCP连接（3次握手）；</li>\n<li>参数从客户端传递到服务器端；</li>\n<li>服务器端得到客户端参数之后，进行相应的业务处理，再将结果封装成HTTP包，返回给客户端；</li>\n<li>服务器端和客户端的交互完成，断开TCP连接（4次挥手）；</li>\n<li>浏览器通过自身执行引擎，渲染并展示最终结果给用户；</li>\n</ol>\n<h4 id=\"DNS域名解析\"><a href=\"#DNS域名解析\" class=\"headerlink\" title=\"DNS域名解析\"></a>DNS域名解析</h4><p>在网络中定位依靠IP进行身份定位，所以URL访问的第一步便是先要的到服务器端的IP地址。而得到服务器的IP地址需要使用 DNS（Domain Name System，域名系统）域名解析，DNS 域名解析就是通过 URL 找到与之相对应的 IP 地址。</p>\n<blockquote>\n<p>PS：为什么不直接访问 IP 地址来请求服务器？因为 IP 地址很长，不方便记忆，而 URL 地址好记很多，所以会使用 URL 来替代 IP 地址，而 URL 就像 IP 地址的别名一样，用它可以定位到相应的 IP 地址。</p>\n</blockquote>\n<p>DNS 域名解析的大致流程如下：</p>\n<ol>\n<li>先检<strong>查浏览器中的 DNS 缓存</strong>，如果浏览器中有对应的记录会直接使用，并完成解析；</li>\n<li>如果浏览器没有缓存，那就去<strong>查询操作系统的缓存</strong>，如果查询到记录就可以直接返回 IP 地址，完成解析；</li>\n<li>如果操作系统没有 DNS 缓存，就会去<strong>查看本地 host 文件</strong>，Windows 操作系统下，host 文件一般位于 “C:\\Windows\\System32\\drivers\\etc\\hosts”，如果 host 文件有记录则直接使用；</li>\n<li>如果本地 host 文件没有相应的记录，会<strong>请求本地 DNS 服务器</strong>，本地 DNS 服务器一般是由本地网络服务商如移动、电信提供。通常情况下可通过 DHCP 自动分配，当然你也可以自己手动配置。目前用的比较多的是谷歌提供的公用 DNS 是 8.8.8.8 和国内的公用 DNS 是 114.114.114.114。</li>\n<li>如果本地 DNS 服务器没有相应的记录，就会<strong>去根域名服务器查询</strong>了，目前全球一共有 13 组根域名服务器（这里并不是指 13 台服务器，是指 13 个 ip 地址，按字母 a-m 编号），为了能更高效完成全球所有域名的解析请求，根域名服务器本身并不会直接去解析域名，而是会把不同的解析请求分配给下面的其他服务器去完成，下面是 DNS 域名系统的树状结构图：</li>\n</ol>\n<p><img data-src=\"https://i.imgtg.com/2023/03/09/Y9b0L.png\" alt=\"image-20220827163817691\"></p>\n<h4 id=\"封装HTTP请求数据包\"><a href=\"#封装HTTP请求数据包\" class=\"headerlink\" title=\"封装HTTP请求数据包\"></a>封装HTTP请求数据包</h4><p>一个 HTTP 请求对象包含 4 部分内容：</p>\n<ol>\n<li>请求行</li>\n<li>请求报头</li>\n<li>空行</li>\n<li>请求正文</li>\n</ol>\n<p><img data-src=\"https://i.imgtg.com/2023/03/09/Y9xMi.png\" alt=\"image-20220827163918979\"></p>\n<p>在得到了服务器IP后，紧接着会将本地的请求封装成一个HTTP数据包，如上图所示。</p>\n<h4 id=\"封装TCP请求数据包\"><a href=\"#封装TCP请求数据包\" class=\"headerlink\" title=\"封装TCP请求数据包\"></a>封装TCP请求数据包</h4><p>HTTP底层是依赖TCP/IP协议实现的，所以在底层数据传输时，会将HTTP请求包进一步封装成TCP数据包。</p>\n<h4 id=\"建立TCP连接（3次握手）\"><a href=\"#建立TCP连接（3次握手）\" class=\"headerlink\" title=\"建立TCP连接（3次握手）\"></a>建立TCP连接（3次握手）</h4><p>HTTP 通讯的基础是 TCP 连接，TCP 连接需要 3 次握手，3 次握手就是为了验证客户端的发送能力和接收能力，以及服务器端的发生能力和接收能力，就像打电话一样，通常的通话是这样开头的：</p>\n<ol>\n<li>_我_：喂，能听到吗？</li>\n<li>_对方_：能听到，你能听到吗？（证明了对方的接收能力和我的发送能力）</li>\n<li>_我_：我也能听到，咱们聊正事吧。（证明了对方的发送能力和我的接收能力）</li>\n</ol>\n<p>经过以上 3 次握手就可以证明客户端的发送能力和接收能力，以及服务器端的发生能力和接收能力，这样就可以正式开始通讯了。</p>\n<h4 id=\"服务器端获取到HTTP请求参数\"><a href=\"#服务器端获取到HTTP请求参数\" class=\"headerlink\" title=\"服务器端获取到HTTP请求参数\"></a>服务器端获取到HTTP请求参数</h4><p>数据在经过TCP传到服务器程序后，又会将TCP的数据包转换成HTTP数据包（这一切都是 TCP/IP 协议的功劳），这样服务器端就可以得到客户端发送的请求数据了。</p>\n<h4 id=\"服务器端执行业务处理，并返回数据\"><a href=\"#服务器端执行业务处理，并返回数据\" class=\"headerlink\" title=\"服务器端执行业务处理，并返回数据\"></a>服务器端执行业务处理，并返回数据</h4><p>服务器端拿到了客户端的请求参数之后，会进行相应的业务处理，处理完成之后，再将处理的结果返回给客户端。返回的流程和发送的流程类似，先将结果封装成 HTTP 数据包，HTTP 数据包可分为以下 4 部分：</p>\n<ol>\n<li>状态行</li>\n<li>响应报头</li>\n<li>空行</li>\n<li>响应正文</li>\n</ol>\n<p>它的基本格式如下：</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/09/Y9z1X.png\" alt=\"image-20220827165323473\"></p>\n<p>状态行用于描述服务器的返回状态，它由 3 部分组成：</p>\n<ol>\n<li>HTTP 版本号，如 HTTP/1.1；</li>\n<li>状态码，如 200；</li>\n<li>状态描述信息，如 OK；</li>\n</ol>\n<p>常见的状态码有以下几个：</p>\n<ul>\n<li>200：返回成功；</li>\n<li>301：永久重定向；</li>\n<li>302：临时重定向；</li>\n<li>404：未找到页面；</li>\n<li>500：服务器程序出错。</li>\n</ul>\n<p>响应正文就是返回给客户端的所有数据。</p>\n<h4 id=\"断开TCP连接（4次挥手）\"><a href=\"#断开TCP连接（4次挥手）\" class=\"headerlink\" title=\"断开TCP连接（4次挥手）\"></a>断开TCP连接（4次挥手）</h4><p>在经过一次请求和一次响应之后，客户端和服务器的“交流”就结束了，此时就可以执行 TCP 连接断开的流程了，它需要 4 次挥手：</p>\n<ul>\n<li>_客户端_：咱们分手吧；</li>\n<li>_服务器端_：好的，让我准备一下。</li>\n<li>_服务器端_：我准备好了，分手吧。</li>\n<li>_客户端_：好的。</li>\n</ul>\n<p>经过了以上流程之后，TCP 的连接就断开了。</p>\n<h4 id=\"浏览器渲染并展示结果\"><a href=\"#浏览器渲染并展示结果\" class=\"headerlink\" title=\"浏览器渲染并展示结果\"></a>浏览器渲染并展示结果</h4><p>经过TCP交互之后，客户端也得到了服务器端返回的数据，然后使用浏览器自身的执行引擎，将最终的结果展示给用户，整个执行流程就结束了。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/",
            "url": "http://example.com/2022/08/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/",
            "title": "并发编程入门（1）：可见性、原子性和有序性",
            "date_published": "2022-08-27T13:07:03.041Z",
            "content_html": "<h4 id=\"并发程序幕后的故事\"><a href=\"#并发程序幕后的故事\" class=\"headerlink\" title=\"并发程序幕后的故事\"></a>并发程序幕后的故事</h4><p>一个核心矛盾：cpu、内存、I/O设备的速度差异</p>\n<p>cpu的速度是内存的100倍，</p>\n<p>内存是I/O的100倍。</p>\n<p>而程序大部分语句要访问内存，有些还要访问I/O，所以程序整体的性能屈居于最慢的操作—读写I/O设备。单方面提高cpu性能是无效的。</p>\n<p>为了平衡这三者的速度差异，计算机体系结构，操作系统，编译程序都做出了贡献：</p>\n<ol>\n<li>cpu增加了缓存，以均衡与内存的速度差异；</li>\n<li>操作系统增加了进程、线程，以分时复用cpu，以均衡cpu与I/O设备的速度差异；</li>\n<li>编译程序优化指令执行次序，使得缓存能够得到更加合理的利用。</li>\n</ol>\n<p>但是，并发程序很多问题的根源也在这里。</p>\n<h4 id=\"源头之一：缓存导致的可见性问题\"><a href=\"#源头之一：缓存导致的可见性问题\" class=\"headerlink\" title=\"源头之一：缓存导致的可见性问题\"></a>源头之一：缓存导致的可见性问题</h4><p>一个线程对共享变量的修改，另外一个线程能够立即看到，我们称之为可见性。</p>\n<p>在单核时代，cpu缓存与内存数据的一致性很好解决。</p>\n<p>在多核时代，每个cpu都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的“坑”。</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/09/Y9qxK.png\" alt=\"image-20220826144959349\"></p>\n<h4 id=\"源头之二：线程切换带来的原子性问题\"><a href=\"#源头之二：线程切换带来的原子性问题\" class=\"headerlink\" title=\"源头之二：线程切换带来的原子性问题\"></a>源头之二：线程切换带来的原子性问题</h4><p>由于IO太慢，早期的操作系统就发明了多进程，即使在单核的cpu上，我们也可以一边听歌一边写代码。</p>\n<p>java并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count += 1，至少需要三条 CPU 指令。</p>\n<p>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</p>\n<p>指令 2：之后，在寄存器中执行 +1 操作；</p>\n<p>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</p>\n<p>操作系统做任务切换，可以发生在任何一条CPU 指令执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/09/Y95Ja.png\" alt=\"image-20220826154247317\"></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E6%B5%AE%E7%82%B9%E5%9E%8B%E8%A1%A8%E7%A4%BA%E9%87%91%E9%A2%9D/",
            "url": "http://example.com/2022/08/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E6%B5%AE%E7%82%B9%E5%9E%8B%E8%A1%A8%E7%A4%BA%E9%87%91%E9%A2%9D/",
            "title": "为什么不能用浮点型表示金额",
            "date_published": "2022-08-22T07:26:44.498Z",
            "content_html": "<p>由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p>\n<p>建议使用BigDecimal或者Long（单位为分）来表示金额。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/22/%E7%B1%BB%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/",
            "url": "http://example.com/2022/08/22/%E7%B1%BB%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/",
            "title": "类变量，成员变量和局部变量",
            "date_published": "2022-08-22T07:26:44.492Z",
            "content_html": "<p>java 中共有三种变量，分别是类变量，成员变量和局部变量。分别存放在 jvm 的方法区、堆内区、和栈内区中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Variables</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 类变量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 成员变量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 局部变量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> c</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>a 是类变量，b 是成员变量，而变量 c 和 d 是局部变量。</p>\n<p>因为只有共享变量才会遇到并发问题，所以，变量 a 和 b 是共享变量，变量 c 和 d 是非共享变量。所以如果遇到多线程场景，对于变量 a 和 b 的操作是需要考虑线程安全的，而对于线程 c 和 d 的操作是不需要考虑线程安全的。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/22/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/",
            "url": "http://example.com/2022/08/22/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/",
            "title": "构造函数",
            "date_published": "2022-08-22T07:26:44.485Z",
            "content_html": "<p>主要用来创建对象时初始化对象，即为对象那个 成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 矩形</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> length, <span class=\"keyword\">int</span> width)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.length = length;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span> <span class=\"params\">(String []args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用构造函数创建对象</span></span><br><span class=\"line\">        Rectangle rectangle = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">10</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。</p>\n<p>构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。</p>\n<p>构造器的函数名称必须和它所属的类的名称相同。它承担着初始化对象数据成员的任务。</p>\n<p>如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如int -&gt; 0，Integer -&gt; null。</p>\n<p>如果在编写一个可实例化的类时没有专门编写构造函数，默认情况下，一个Java类中会自动生成一个默认无参构造函数。默认构造函数一般会把成员变量的值初始化为默认值，如int -&gt; 0，Integer -&gt; null。</p>\n<p>但是，如果我们手动在某个类中定义了一个有参数的构造函数，那么这个默认的无参构造函数就不会自动添加了。需要手动创建！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 矩形</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> length, <span class=\"keyword\">int</span> width)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.length = length;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 无参构造函数</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/22/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/",
            "url": "http://example.com/2022/08/22/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/",
            "title": "方法重写和重载",
            "date_published": "2022-08-22T07:26:44.476Z",
            "content_html": "<p>重载：指的是在同一个类中，多个函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p>\n<p>重写：指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重载</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;woof &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//overloading method</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bark</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;num; i++)</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;woof &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定具体哪个bark方法被调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重载</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;woof &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hound</span> <span class=\"keyword\">extends</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sniff</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sniff &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;bowl&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OverridingTest</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span></span>&#123;</span><br><span class=\"line\">        Dog dog = <span class=\"keyword\">new</span> Hound();</span><br><span class=\"line\">        dog.bark();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bowl</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中，我们分别在父类、子类中都定义了bark方法，并且他们都是无参方法，所以我们就说这种情况就是方法重写。即子类Hound重写了父类Gog中的bark方法。</p>\n<p>在测试的main方法中，<code>dog</code>对象被定义为<code>Dog</code>类型。</p>\n<p>在编译期，编译器会检查Dog类中是否有可访问的<code>bark()</code>方法，只要其中包含<code>bark（）</code>方法，那么就可以编译通过。</p>\n<p>在运行期，<code>Hound</code>对象被<code>new</code>出来，并赋值给<code>dog</code>变量，这时，JVM是明确的知道<code>dog</code>变量指向的其实是<code>Hound</code>对象的引用。所以，当<code>dog</code>调用<code>bark()</code>方法的时候，就会调用<code>Hound</code>类中定义的<code>bark（）</code>方法。这就是所谓的动态多态性。</p>\n<p>方法重写需满足以下条件</p>\n<p>1、参数列表必须完全与被重写方法的相同； 2、返回类型必须完全与被重写方法的返回类型相同； 3、访问级别的限制性一定不能比被重写方法的强； 4、访问级别的限制性可以比被重写方法的弱； 5、重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常 6、重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明） 7、不能重写被标示为final的方法； 8、如果不能继承一个方法，则不能重写这个方法。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/21/%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2022/08/21/%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/",
            "title": "多继承问题",
            "date_published": "2022-08-21T09:04:26.664Z",
            "content_html": "<p>Java 中支持一个类同时实现多个接口，但是不支持同时继承多个类。但是这个问题在 Java 8 之后也不绝对了。</p>\n<p>一个类，只有一个父类的情况，我们叫做单继承。而一个类，同时有多个父类的情况，叫做多继承。</p>\n<p>在 Java 中，一个类，只能通过 extends 关键字继承一个类，不允许多继承。但是，多继承在其他的面向对象语言中是有可能支持的。</p>\n<p>像 C++ 就是支持多继承的，主要是因为编程的过程是对现实世界的一种抽象，而现实世界中，确实存在着需要多继承的情况。比如维基百科中关于多继承举了一个例子：</p>\n<p>例如，可以创造一个 “哺乳类动物” 类别，拥有进食、繁殖等的功能；然后定义一个子类型 “猫”，它可以从父类继承上述功能。</p>\n<p>但是，&quot;猫&quot; 还可以作为 &quot;宠物&quot; 的子类，拥有一些宠物独有的能力。</p>\n<p>所以，有些面向对象语言是支持多重继承的。</p>\n<p>但是，多年以来，多重继承一直都是一个敏感的话题，反对者指它增加了程序的复杂性与含糊性。</p>\n<h3 id=\"菱形继承问题\"><a class=\"markdownIt-Anchor\" href=\"#菱形继承问题\">#</a> 菱形继承问题</h3>\n<p>假设我们有类 B 和类 C，它们都继承了相同的类 A。另外我们还有类 D，类 D 通过多重继承机制继承了类 B 和类 C。</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/10/Y83ic.png\" alt=\"img\"></p>\n<p>这时候，因为 D 同时继承了 B 和 C，并且 B 和 C 又同时继承了 A，那么，D 中就会因为多重继承，继承到两份来自 A 中的属性和方法。</p>\n<p>这时候，在使用 D 的时候，如果想要调用一个定义在 A 中的方法时，就会出现歧义。</p>\n<p>因为这样的继承关系的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。</p>\n<p>而 C++ 为了解决菱形继承问题，又引入了<strong>虚继承</strong>。</p>\n<p>因为支持多继承，引入了菱形继承问题，又因为要解决菱形继承问题，引入了虚继承。而经过分析，人们发现我们其实真正想要使用多继承的情况并不多。</p>\n<p>所以，在 Java 中，不允许 “实现多继承”，即一个类不允许继承多个父类。但是 Java 允许 “声明多继承”，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现（Java 8 以前），这就避免了 C++ 中多继承的歧义问题。</p>\n<p>但是，Java 不支持多继承，在 Java 8 中支持了默认函数（default method ）之后就不那么绝对了。</p>\n<p>虽然我们还是没办法使用 extends 同时继承多个类，但是因为有了默认函数，我们有可能通过 implements 从多个接口中继承到多个默认函数，那么，又如何解决这种情况带来的菱形继承问题呢？</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/19/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/",
            "url": "http://example.com/2022/08/19/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/",
            "title": "java中的多态",
            "date_published": "2022-08-19T07:57:49.921Z",
            "content_html": "<p>同一操作作用于不同的对象，可以有不同的解释，产生不同的结果。</p>\n<p>java中的多态是一种运行期的状态。满足三个条件：</p>\n<ul>\n<li>有类继承或者接口实现</li>\n<li>子类要重写父类的方法</li>\n<li>父类的引用指向子类的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        sout(<span class=\"string\">&quot;im Parent&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span></span>&#123;<span class=\"comment\">// 1.有类继承或者接口实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">// 2.子类要重写父类的方法</span></span><br><span class=\"line\">        sout(<span class=\"string\">&quot;im Son&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span></span>&#123;<span class=\"comment\">// 1.有类继承或者接口实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">// 2.子类要重写父类的方法</span></span><br><span class=\"line\">        sout(<span class=\"string\">&quot;im Daughter&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Parent p = <span class=\"keyword\">new</span> Son(); <span class=\"comment\">//3.父类的引用指向子类的对象</span></span><br><span class=\"line\">        Parent p1 = <span class=\"keyword\">new</span> Daughter(); <span class=\"comment\">//3.父类的引用指向子类的对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样，就实现了多态，同样是Parent类的实例，p.call 调用的是Son类的实现、p1.call调用的是Daughter的实现。</p>\n<p>有人说，你自己定义的时候不就已经知道p是son，p1是Daughter了么。但是，有些时候你用到的对象并不都是自己声明的。</p>\n<p>比如Spring 中的IOC出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。</p>\n<blockquote>\n<p>IOC，是Ioc—Inversion of Control 的缩写，中文翻译成“控制反转”，它是一种设计思想，意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p>\n<p>换句话说当我们使用Spring框架的时候，对象是Spring容器创建出来并由容器进行管理，我们只需要使用就行了。</p>\n</blockquote>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/09/01/OP-TEE%E4%B8%ADTA%E4%B8%8ECA%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-------%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%AF%87/",
            "url": "http://example.com/2021/09/01/OP-TEE%E4%B8%ADTA%E4%B8%8ECA%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-------%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%AF%87/",
            "title": "OP-TEE中TA与CA执行流程详解--软件架构篇",
            "date_published": "2021-09-01T12:41:18.848Z",
            "content_html": "<p>要使用OP-TEE来实现特定的安全功能就需要开发者根据自己的实际需求开发特定的CA和TA程序，并将TA集成到OP-TEE中。CA端负责实现在RTOS端userspace层面的对外接口，而TA端的代码则是在OP-TEE OS的userspace层面负责实现具体的安全功能，例如使用何种算法组合来对数据进行安全处理，对处理后的数据的安全保存，解密加密数据等等功能。接下来的章节将详细介绍CA到TA之间的所有流程以及相关结构体设置，接口调用等等，关于如何在OP-TEE中添加自有的TA和CA程序请参考文档《2. OP-TEE中添加自己的TA和CA》。关于OP-TEE的中断处理的流程请查阅《OP-TEE中的中断处理》相关文章，接下来的章节将介绍不考虑中断的情况下，一个完整的TA和CA之间进行调用的完整过程分析。下图为系统中CA与TA之间执行的软件框图。</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/10/YX5qD.png\" alt=\"img\"></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/09/01/OP-TEE%E4%B8%ADCA%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B------%E7%B3%BB%E7%BB%9F%E5%90%84%E5%B1%82%E9%9D%A2%E5%85%B3%E7%B3%BB/",
            "url": "http://example.com/2021/09/01/OP-TEE%E4%B8%ADCA%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B------%E7%B3%BB%E7%BB%9F%E5%90%84%E5%B1%82%E9%9D%A2%E5%85%B3%E7%B3%BB/",
            "title": "OP-TEE中CA接口调用的完整流程--系统各层面关系",
            "date_published": "2021-09-01T11:31:10.665Z",
            "content_html": "<p>二级厂商需要实现自有feature，需要添加自己的TA 和CA接口，当CA部分的接口需要提供给app层面调用的时候，一般做法是在framwork中建立特定的service，在service中调用CA接口。同时也会建立对应的client部分，一般做法是在framwork中建立特定的service，在service中调用CA接口，同时也会建立对应的client部分，client部分与service部分通过Binder的方式进行同行来触发CA接口调用的操作。而对于APP层面，开发者会将client部分提供的接口以JNI的方式进行封装暴露给上层APP调用。</p>\n<p>当上层APP调用封装好的JNI接口后，CA接口是如何通知特定的TA执行特定操作的呢？CA与TA之间的数据是如何传递的呢？cortex的状态是如何切换的呢？本文将详细讲解一次CA接口调用后功能实现的完整流程（本文不讨论FIQ和IRQ的情况，只讨论通过调用SMC指令调用到TEE的情况）。</p>\n<h2 id=\"1-支持TEE的系统各层面关系图\"><a href=\"#1-支持TEE的系统各层面关系图\" class=\"headerlink\" title=\"1.支持TEE的系统各层面关系图\"></a>1.支持TEE的系统各层面关系图</h2><p>下图为层面结构图：</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/10/Y86qU.png\" alt=\"img\"></p>\n<p>　当CA接口处于userspace层面，整个调用过程需要经过kernel space层面， linux driver层面， Monitor态中断处理层面， TEE OS kernel层面， TEE的userspace层面（TA）。</p>\n<h2 id=\"2-userspace到kernelspace\"><a href=\"#2-userspace到kernelspace\" class=\"headerlink\" title=\"2.userspace到kernelspace\"></a>2.userspace到kernelspace</h2><p>在userspace层面调用CA接口后会触发system call操作，系统调用会将Lixnux陷入内核态，此时系统处于kernel space，然后根据传入的参数，找到对应的TEE driver，整个过程大致如下：</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/10/Y88rY.png\" alt=\"img\"></p>\n<p>关于该部分更加详细的内容，例如：软中断如何在kernel中注册的，系统调用的定义等等可查找系统调用（systemcall）和驱动的相关资料进行了解。</p>\n<h2 id=\"3-TEE-driver到monitor态\"><a href=\"#3-TEE-driver到monitor态\" class=\"headerlink\" title=\"3.TEE driver到monitor态\"></a>3.TEE driver到monitor态</h2><p>在TEE的driver中，最终会调用SMC这条汇编指令来实现与OP-TEE的沟通，当调用SMC汇编指令之后，会触发SMC软中断，改软中断的处理在Cortex的Monitor态中进行，该软中断会根据发送指令是属于安全侧请求哈市非安全侧的请求来控制是将cortex切换到secure world态还是non-secure world态。该切换动作在ATF的SMC中断处理函数中被实现。</p>\n<h2 id=\"4-TEE-kernel-space到TEE-userspace\"><a href=\"#4-TEE-kernel-space到TEE-userspace\" class=\"headerlink\" title=\"4.TEE kernel space到TEE userspace\"></a>4.TEE kernel space到TEE userspace</h2><p>当SMC中断处理函数完成了将cortex的状态切换到secure world态以及相关参数的拷贝动作之后，TEE OS将接管剩下的操作。TEE OS首先将会获取从CA端传递过来的数据，然后解析出数据中写入的TA的UUID，然后查找对应的TA image是否被挂载到了 TEE OS中。</p>\n<p>　　如果没有TEE OS将会与常驻在linux中的tee_supplicant进程通信，从文件系统中获取到TA image文件，并传递給TEE OS，然后加载该TA image。处理完整之后，TEE OS会切换到TEE userspace态，并将CA传递过来的其他参数传给具体的TA process，TA process获取到参数后，首先需要解除出参数中的commond ID值，根据具体的command ID值来做具体的操作。</p>\n<p>当然TEE OS在加载TA image的时候会有电子验签操作来验证TA image的合法性。上述步骤的大致流程图如下：<br><img data-src=\"https://i.imgtg.com/2023/03/10/Y8XQv.png\" alt=\"img\"></p>\n<p>由于一次完整的CA调用过程需要做一次调用执行initContext, Opensession, InvokeCommand, close session, FinalizeContext操作，所以上图只是大致流程，关于详细部分将会在后期章节中节后代码逐步讲解。</p>\n<h2 id=\"5-GP规定的C端接口\"><a href=\"#5-GP规定的C端接口\" class=\"headerlink\" title=\"5.GP规定的C端接口\"></a>5.GP规定的C端接口</h2><p>在GP中规定的CA端接口较少，主要的是五个接口，分别如下：</p>\n<p>TEEC_InitializeContext: 初始化TEE context，完成open tee driver，建立与TEE之间的context</p>\n<p>TEEC_OpenSession: 建立CA与TA之间的会话窗口</p>\n<p>TEEC_InvokeCommand: 想TA发送执行请求来执行具体的操作</p>\n<p>TEEC_CloseSession: 关闭CA与TA之间的会话窗口</p>\n<p>TEEC_FinalizeContext:清空建立的contex</p>\n<hr>\n<p>转载自：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NodWFpZmVuZ3l1bi9hcnRpY2xlL2RldGFpbHMvNzE2OTczNzE=\">https://blog.csdn.net/shuaifengyun/article/details/71697371</span></p>\n<p>自己差不多抄了一遍，大概流程看了一下，还是有些细节不太懂。很多操作没有见过，也不知道为什么要这样做。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/08/27/3%20Modern%20Trusted%20Computing%20Hardware/",
            "url": "http://example.com/2021/08/27/3%20Modern%20Trusted%20Computing%20Hardware/",
            "title": "3 Modern Trusted Computing Hardware",
            "date_published": "2021-08-27T07:40:49.262Z",
            "content_html": "<p>本章介绍了ARM TrustZone的背景及其缺点。</p>\n<h2 id=\"3-1-ARM-TrustZone\"><a href=\"#3-1-ARM-TrustZone\" class=\"headerlink\" title=\"3.1 ARM TrustZone\"></a>3.1 <strong>ARM TrustZone</strong></h2><p>ARM TrustZone 是 ARM 对可信计算的硬件支持。它是在许多最新的 ARM 处理器（包括 Cortex A8、Cortex A9 和 Cortex A15）中发现的一组安全扩展。 ARM TrustZone 提供两个由硬件访问控制支持的虚拟处理器。分别为secure world(SW)和normal world (NW)，根据单个 ARM SoC 的具体情况，单个资源可以在两个世界之间进行强分区，可以跨世界共享，或仅分配给单个世界。</p>\n<h3 id=\"Secure-monitor\"><a href=\"#Secure-monitor\" class=\"headerlink\" title=\"Secure monitor.\"></a><strong>Secure monitor.</strong></h3><p>安全监视器是一种 ARM 处理器模式，旨在在安全和正常世界之间切换</p>\n<h3 id=\"Secure-world-entry-exit\"><a href=\"#Secure-world-entry-exit\" class=\"headerlink\" title=\"Secure world entry/exit.\"></a><strong>Secure world entry/exit.</strong></h3><p>根据设计，ARM 平台总是首先进入安全世界。 在这里，系统固件可以在任何不受信任的代码（例如操作系统）有机会运行之前提供安全世界的运行时环境。</p>\n<h3 id=\"Curtained-memory\"><a href=\"#Curtained-memory\" class=\"headerlink\" title=\"Curtained memory\"></a><strong>Curtained memory</strong></h3><p>在启动时，在安全监视器中运行的软件可以仅将一系列物理地址分配给安全世界，从而创建窗帘内存的抽象——系统其余部分无法访问内存。</p>\n<h2 id=\"3-2-Shortcomings-of-ARM-TrustZone\"><a href=\"#3-2-Shortcomings-of-ARM-TrustZone\" class=\"headerlink\" title=\"3.2 Shortcomings of ARM TrustZone\"></a><strong>3.2 Shortcomings of ARM TrustZone</strong></h2><p>尽管 ARM TrustZone 规范描述了在安全世界中如何保护处理器和内存子系统，该规范没有说明应该如何保护大多数其他资源。 这导致了碎片化——SoC 为 TrustZone 提供了各种形式的不同硬件资源保护，或者根本没有保护。</p>\n<h3 id=\"Storage-（No-trusted-storage）\"><a href=\"#Storage-（No-trusted-storage）\" class=\"headerlink\" title=\"*Storage.*（No trusted storage）\"></a>*Storage.*（No trusted storage）</h3><p>令人惊讶的是，ARM TrustZone 规范没有提供有关如何为 TrustZone 实施安全存储的指南。 缺乏安全存储大大降低了 TrustZone 作为可信计算硬件的有效性。</p>\n<h3 id=\"Crypto-needs-（No-trusted-storage）\"><a href=\"#Crypto-needs-（No-trusted-storage）\" class=\"headerlink\" title=\"**Crypto needs.**（No trusted storage）\"></a>**Crypto needs.**（No trusted storage）</h3><p>大多数受信任的系统都使用密码学。 然而，该规范并未提及提供安全的熵源或单调递增的计数器。</p>\n<h3 id=\"Lack-of-virtualization\"><a href=\"#Lack-of-virtualization\" class=\"headerlink\" title=\"Lack of virtualization.\"></a><strong>Lack of virtualization.</strong></h3><p>当今移动设备中使用的大多数基于 ARM 的 SoC 都缺乏虚拟化支持。 在缺乏虚拟化硬件辅助的 ARM 平台上虚拟化商用操作系统（例如 Windows）非常困难。</p>\n<h3 id=\"Lack-of-secure-clock-and-other-peripherals\"><a href=\"#Lack-of-secure-clock-and-other-peripherals\" class=\"headerlink\" title=\"Lack of secure clock (and other peripherals).\"></a><strong>Lack of secure clock (and other peripherals).</strong></h3><p>系统通常需要一个安全时钟。 虽然 TrustZone<br>访问受保护的内存和中断是向提供安全外设迈出的一步，但如果不保护可以与这些外设通信的总线控制器，通常是不够的。</p>\n<h3 id=\"Lack-of-access\"><a href=\"#Lack-of-access\" class=\"headerlink\" title=\"Lack of access\"></a><strong>Lack of access</strong></h3><p>大多数 SoC 硬件供应商不提供对其固件的访问。 因此，许多开发人员和研究人员无法找到将他们的系统或原型部署到 TrustZone 的方法。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/08/20/TZ%E5%AD%A6%E4%B9%A0%E7%BB%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932021.8.9-2021.8.20/",
            "url": "http://example.com/2021/08/20/TZ%E5%AD%A6%E4%B9%A0%E7%BB%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932021.8.9-2021.8.20/",
            "title": "TZ学习组学习总结2021.8.9-2021.8.20",
            "date_published": "2021-08-20T10:43:25.579Z",
            "content_html": "<p>姓名：胡晨</p>\n<h2 id=\"一-本段时间的学习内容\"><a class=\"markdownIt-Anchor\" href=\"#一-本段时间的学习内容\">#</a> 一、 本段时间的学习内容：</h2>\n<h3 id=\"a-学习的详细内容1成功搭建optee环境\"><a class=\"markdownIt-Anchor\" href=\"#a-学习的详细内容1成功搭建optee环境\">#</a> A. 学习的详细内容 1：成功搭建 optee 环境。</h3>\n<p>学习成果 1：进度安排（各工作是否达到预期等）：达到。</p>\n<h3 id=\"b学习的内容2实践taca的简单套路了解了执行的流程看了一些相关的视频httpswwwbilibilicomvideobv1l4411n7gzp1和博客httpsicyshuaiblogcsdnnetarticledetails73716352\"><a class=\"markdownIt-Anchor\" href=\"#b学习的内容2实践taca的简单套路了解了执行的流程看了一些相关的视频httpswwwbilibilicomvideobv1l4411n7gzp1和博客httpsicyshuaiblogcsdnnetarticledetails73716352\">#</a> B. 学习的内容 2：实践 TA,CA 的简单套路，了解了执行的流程，看了一些相关的视频（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUw0NDExTjdnWj9wPTElRUYlQkMlODklRTUlOTIlOEMlRTUlOEQlOUElRTUlQUUlQTIlRUYlQkMlODhodHRwczovL2ljeXNodWFpLmJsb2cuY3Nkbi5uZXQvYXJ0aWNsZS9kZXRhaWxzLzczNzE2MzUyJUVGJUJDJTg5\">https://www.bilibili.com/video/BV1L4411N7gZ?p=1）和博客（https://icyshuai.blog.csdn.net/article/details/73716352）</span></h3>\n<p>学习成果 2：进度安排（各工作是否达到预期等）：达到。</p>\n<h2 id=\"二-困难和解决方案\"><a class=\"markdownIt-Anchor\" href=\"#二-困难和解决方案\">#</a> 二、困难和解决方案：</h2>\n<p>以下给出我总结的 optee 环境搭建方法（经过多次尝试，该方法可将时间缩短到两小时内，且必成功）：</p>\n<p>1. 首先，unbuntu 选择 18.04 版本，这是一切的基础，想必大家都知道版本的重要。（其他版本可能或多或少有难以解决的问题）。给出下载网址：<span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuMTYzLmNvbS91YnVudHUtcmVsZWFzZXMvMTguMDQv\">http://mirrors.163.com/ubuntu-releases/18.04/</span></p>\n<p>2. 使用如下指令安装搭建时需要的工具和库（此时使用 Ubuntu18.04 不会有任何报错，但是其他版本会有包安装不了，从而会导致后面一些莫名其妙的错误。）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install android-tools-adb android-tools-fastboot autoconf \\</span><br><span class=\"line\">\tautomake bc bison build-essential cscope curl device-tree-compiler \\</span><br><span class=\"line\">\texpect flex ftp-upload gdisk iasl libattr1-dev libc6:i386 libcap-dev \\</span><br><span class=\"line\">\tlibfdt-dev libftdi-dev libglib2.0-dev libhidapi-dev libncurses5-dev \\</span><br><span class=\"line\">\tlibpixman-1-dev libssl-dev libstdc++6:i386 libtool libz1:i386 make \\</span><br><span class=\"line\">\tmtools netcat python-crypto python-serial python-wand unzip uuid-dev \\</span><br><span class=\"line\">\txdg-utils xterm xz-utils zlib1g-dev</span><br></pre></td></tr></table></figure>\n<p>3. 下载 OP-TEE 的源代码</p>\n<p>此时直接从网盘中下载就可以了，千万不要自己同步，可能出现 python 版本不对等问题网盘链接如下：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVQ5dHNPblEzRWJ6OXdtN2liekJMcHc=\">https://pan.baidu.com/s/1T9tsOnQ3Ebz9wm7ibzBLpw</span></p>\n<p>提取码: cd94</p>\n<p>把压缩包复制到 ubuntu 中再解压就可以了（解压出来的文件层数过多，例如 /op-tee/OP-TEE/… , 可以只留一个大文件目录方便操作）</p>\n<p>5. 获取 toolchain</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd build</span><br><span class=\"line\">$ make -f qemu.mk all</span><br></pre></td></tr></table></figure>\n<p>6. 启动 qemu（仍然在 build 目录下）</p>\n<p>如果你不信邪，直接执行下面命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make -f qemu.mk run-only</span><br></pre></td></tr></table></figure>\n<p>此时必然会出现一个问题：</p>\n<p>*** [/home/rhj0/open-tee/qemu/rules.mak:69：util/memfd.o] 错误 1</p>\n<p>此时就需要修改文件里的代码。（可以直接在文件里搜索关键代码，方便寻找）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; qemu&#x2F;util&#x2F;memfd.c文件中的： </span><br><span class=\"line\">#ifdef CONFIG_MEMFD </span><br><span class=\"line\">#include &lt;sys&#x2F;memfd.h&gt; </span><br><span class=\"line\">#elif defined CONFIG_LINUX </span><br><span class=\"line\">&#x2F;&#x2F; 改为： #if defined CONFIG_LINUX &amp;&amp; !defined CONFIG_MEMFD </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; qemu&#x2F;configure文件中的： </span><br><span class=\"line\">#include &lt;sys&#x2F;memfd.h&gt; </span><br><span class=\"line\">&#x2F;&#x2F; 改为： #include &lt;sys&#x2F;mman.h&gt;</span><br></pre></td></tr></table></figure>\n<p>附上官方的更改链接（更改和上面一样）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQucWVtdS5vcmcvP3A9cWVtdS5naXQ7YT1jb21taXRkaWZmO2g9NzVlNWI3MGU2YjVkY2M0ZjIyMTk5OTJkN2NmZmE0NjJhYTQwNmFmMDtocD0yMDA3ODBhM2EzZWQwNjdkZmIyZTBkMjIxMGIwZWQwOWU3NDhiYTI2\">https://git.qemu.org/?p=qemu.git;a=commitdiff;h=75e5b70e6b5dcc4f2219992d7cffa462aa406af0;hp=200780a3a3ed067dfb2e0d2210b0ed09e748ba26</span></p>\n<p>再次执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make -f qemu.mk run-only</span><br></pre></td></tr></table></figure>\n<p>就大功告成了。总耗时应该不超过两个小时，甚至网速快的话十几分钟就可以了。</p>\n<p>（以上全是踩坑踩出来的经验和各个评论区大佬的解决方案，本人只是汇总找了条最简单的路）</p>\n<p>对比别的教程把下载和同步源码改成了网盘下载，大大减少了不必要的麻烦。</p>\n<p>最后感谢：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUw0NDExTjdnWj9mcm9tPXNlYXJjaCZhbXA7c2VpZD0zMjU2MTgxNDQ5MjU3MjEzODExJUVGJUJDJTg4\">https://www.bilibili.com/video/BV1L4411N7gZ?from=search&amp;seid=3256181449257213811（</span><strong>推荐观看</strong>）</p>\n<p>和 https://icyshuai.blog.csdn.net/article/details/71499619</p>\n<p>三、 下周预期安排</p>\n<ol>\n<li>下期进度安排：</li>\n</ol>\n<p>尽快熟悉 TA 和 CA 的用法</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/11/c%E7%9A%84const/",
            "url": "http://example.com/2021/03/11/c%E7%9A%84const/",
            "title": "const",
            "date_published": "2021-03-11T04:43:15.593Z",
            "content_html": "<p>const 修饰的数据类型是指常类型，常类型的变量或对象的对象的值是不能被更新的。</p>\n<p>const 推出的初始目的，正是为了取代预编译指令，消除他的缺点，同时继承它的优点。</p>\n<h5 id=\"主要作用\"><a href=\"#主要作用\" class=\"headerlink\" title=\"主要作用\"></a>主要作用</h5><ol>\n<li>可以定义const常量，具有不可变性。例如：const int max = 100；max++会产生错误。</li>\n<li>便于进行类型检查，是编译器对处理内容有更多了解，消除了一些隐患。例如：void f（const int i）{…….}编译器就会知道i是一个常量，不允许修改；</li>\n<li>可以避免意义模糊的数字出现，同样可以很方便的进行参数的调整和修改。同宏定义一样。</li>\n<li>可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。</li>\n<li>可以节省空间，避免不必要的内存分配。如：</li>\n</ol>\n<p>#define PI 3.14159 //常量宏  　　</p>\n<p>const double <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9QaQ==\">Pi</span>=3.14159; //此时并未将Pi放入ROM中 ……  　　</p>\n<p>double i=Pi; //此时为Pi分配内存，以后不再分配！  　　</p>\n<p>double I=PI; //编译期间进行宏替换，分配内存　</p>\n<p>double j=Pi; //没有内存分配  　　</p>\n<p>double J=PI; //再进行宏替换，又一次分配内存！ </p>\n<p>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干份拷贝。</p>\n<h5 id=\"变量和常量\"><a href=\"#变量和常量\" class=\"headerlink\" title=\"变量和常量\"></a>变量和常量</h5><p>例：为什么下面的例子在使用一个const变量来初始化数组，ANSI C编译器会报告一个错误呢？</p>\n<p>const int n = 5；</p>\n<p>int a[n];</p>\n<p> 答案与分析：</p>\n<p>1）这个问题讨论的是“常量与“只读变量”的区别。常量，例如5， “abc”，等，肯定是只读的，因为常量是被编译器放在内存中的只读区域，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时长度必须是“常量” C99标准，数组下标可以用变量来表示），“只读变量”也是不可以的，“常量”不等于“不可变的变量”。但是在C++中，局部数组是可以使用变量作为其长度的。</p>\n<p>2）但是在标准C++中，这样定义的是一个常量，这种写法是对的。实际上，根据编译过程及内存分配ANSI C对数组的规定限制了它（实际上用GCC或VS2005编译以上代码，确实没有错误产生，也没有给出警告）。</p>\n<p>3）那么，在ANSI C中用什么来定义常量呢？答案是enum类型和#define宏，这两个都可以用来定义常量。</p>\n<p>。。。。。</p>\n<p>const 的用法还有很多，今天就先写到这里。</p>\n<p>有需要再添加吧。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/07/%E7%BA%B5%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/",
            "url": "http://example.com/2021/03/07/%E7%BA%B5%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/",
            "title": "纵向联邦学习",
            "date_published": "2021-03-07T08:06:41.564Z",
            "content_html": "<h4 id=\"纵向联邦学习的定义与举例\"><a href=\"#纵向联邦学习的定义与举例\" class=\"headerlink\" title=\"纵向联邦学习的定义与举例\"></a>纵向联邦学习的定义与举例</h4><p>我们把在数据集上具有相同的样本空间、不同的特征空间的参与方所组成的联邦学习归类为纵向联邦学习（VFL）。</p>\n<p>假如有一位用户在一家银行中有一些能够反映出该用户的经济收入、消费习惯和信用评级的数据记录。同时在一家电商平台中记录着这位用户所浏览和购买的商品的历史信息。尽管这两家公司拥有用户数据的特征空间完全不同，他们彼此间却有着紧密的联系。例如，用户的购买历史可能在某种程度上决定了该用户的信用评级。</p>\n<p>出于不同的商业目的，不同的组织拥有的数据通常具有不同的特征空间，但这些组织可能共享一个巨大的用户群体。通过使用VFL，我们可以利用分布于这些组织的异构数据，搭建更好的机器学习模型，并且不需要交换和泄露隐私数据。</p>\n<h4 id=\"纵向联邦学习的架构\"><a href=\"#纵向联邦学习的架构\" class=\"headerlink\" title=\"纵向联邦学习的架构\"></a>纵向联邦学习的架构</h4><p><img data-src=\"https://i.imgtg.com/2023/03/09/Y9OHB.png\" alt=\"image-20210309235515471\"></p>\n<p>举个例子。假设两家公司A和B想要协同地训练一个机器学习模型。每一家公司拥有各自的数据，此外B还拥有进行模型预测任务所需的标注数据。由于用户隐私和数据安全的原因，A方和B 方不能直接交换数据。为了保证训练过程中的数据保密性，加入了一个第三方协调者C。在这里，我们假设C方是诚实且不与A方和B方共谋，但A方和B方都是诚实但好奇的。被信任的第三方是一个合理的假设，因为C方的角色可以有权威机构（如政府）扮演或安全计算节点代替。</p>\n<ul>\n<li>第一部分：加密实体对齐</li>\n</ul>\n<p>由于A方和B方公司的用户群体不同，系统使用一种基于加密的用户ID对齐技术，来确保A方和B方不需要暴露各自的原始数据便可以对齐共同用户。</p>\n<ul>\n<li>第二部分：加密模型训练</li>\n</ul>\n<p>在确定共有实体后，各方可以使用这些共有实体的数据来协同地训练一个机器学习模型。</p>\n<ol>\n<li>协调者C创建密钥对，并将公共密钥发送给A方和B方。</li>\n<li>A方和B方对中间结果进行加密和交换。中间结果用来帮助计算梯度和损失值。</li>\n<li>A方和B方计算加密梯度并分别加入附加掩码。B方还会计算加密损失。A方和B方将加密的结果发送给C方。</li>\n<li>C方对梯度和损失信息进行解密，并将结果发送回A方和B方。A方和B方解除梯度信息上的掩码，并根据这些梯度信息来更新模型参数</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/07/c%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/",
            "url": "http://example.com/2021/03/07/c%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/",
            "title": "C的动态内存分配",
            "date_published": "2021-03-07T02:13:23.228Z",
            "content_html": "<h4 id=\"内存分配的方式\"><a href=\"#内存分配的方式\" class=\"headerlink\" title=\"内存分配的方式\"></a>内存分配的方式</h4><ul>\n<li><strong>在静态存储区域中进行分配</strong></li>\n</ul>\n<p>​        内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量</p>\n<ul>\n<li><strong>在栈中进行分配</strong></li>\n</ul>\n<p>​        在执行函数时，函数内<strong>局部变量</strong>的存储单元都可以在栈上创建，函数执行结束时，这些存储但愿自动被释放。效率很高，但是分配的内存容量比较有限</p>\n<ul>\n<li><strong>在堆中进行分配</strong></li>\n</ul>\n<p>​        在堆上分配也称为动态内存分配：程序在运行的时候用malloc等函数申请任意多少的内存，程序员自己负责在何时用free释放内存。动态内存分配的生存期由我们自己决定，使用非常灵活，但是问题相对也比较多；注意：如果没有释放的话，很容易就会造成内存溢出，因为堆中的内存块是全局的，因此不会因为函数的调用而结束</p>\n<h4 id=\"动态内存分配中使用的函数：\"><a href=\"#动态内存分配中使用的函数：\" class=\"headerlink\" title=\"动态内存分配中使用的函数：\"></a><strong>动态内存分配中使用的函数：</strong></h4><p><strong>1:malloc函数:需要用到的头文件malloc.h</strong></p>\n<p>void *malloc(size_t size) //————–&gt;返回的是一个通用类型的指针，根据需要去进行强转；<br>功能：允许从空闲内存池中分配连续内存但不初始化<br>参数：size参数实际就是一个所需字节数的整数 malloc(20);<br>返回：若分配成功则返回一个指向该内存块的指针，在使用时可根据需要做强制类型转换，否则返回NULL（空指针）//需要判空</p>\n<p>free(p);//释放内存空间,将内存释放出来给系统；<br>free函数与malloc函数是成对出现的；<br>申请malloc的时候尽量去给它进行一下初始化，防止后面出现一些不确定性的东西；<br>malloc的生命周期：只要没有调用free这个函数，进程没有结束，那么此时，这个函数的生命周期就会一直存在在内存中；它是存放在堆空间中的，它不会因为你去函数调用的结束自动去释放，堆当中的内存是全局的。<br>如：int <em>p = (int</em> )malloc(n<em>sizeof(int)); //在<strong>空闲内存池</strong>中分配连续内存n</em>sizeof(int)个字节的<strong>堆内存空间</strong></p>\n<p>malloc的相关实例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;malloc.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">out</span><span class=\"params\">(<span class=\"keyword\">int</span> *p,<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,*(p+i));</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;---------------\\n&quot;</span>);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;please input one number:&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"comment\">//申请</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"comment\">//内存申请成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        out(p,n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            *(p+i)=i*i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        out(p,n);</span><br><span class=\"line\">        <span class=\"comment\">//释放掉堆内存</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//内存申请失败</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;malloc is NULL!\\n&quot;</span>);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2:calloc函数:需要用到的头文件stdlib.h</strong></p>\n<p>void <em>colloc(size_t num_elements,size_t element_size);<br>功能:功能同malloc是一样的，但是作*<em>初始化</em></em><br>参数:num_elements是所需的元素的数量，element_size是每个元素的字节数<br>返回:同malloc函数一样<br>也是需要与free(p)进行对称使用<br>calloc相关代码如下所示:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;please input one number:&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">calloc</span>(n,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,*(p+i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;calloc error\\n&quot;</span>);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3: realloc函数:需要用到的头文件(stdlib.h),动态扩大缩小申请的内存</strong></p>\n<p>void *realloc(void *ptr,size_t new_size);<br>功能:在指针ptr指向的内存基础上扩大或者缩小内存<br>参数:ptr是指向先前通过<strong>malloc,calloc和realloc函数后分配的内存块的指针</strong>，new_size是内存块的新尺寸，可能大于或者小于原有内存尺寸；这个是追加到new_size的新的内存<br>realloc在C语言中也被称为动态数组；<br>realloc函数使用的注意点:<br>1:当扩展内存的时候，不会对添加进内存块的字节进行初始化<br>2:若不能调整内存则返回NULL，但原有内存中的数据是不会发生改变的<br>3:<strong>若第一个参数为NULL那么功能 等同与malloc函数，若第二个参数为0,那么会释放调用内存块</strong></p>\n<blockquote>\n<p><strong>realloc(NULL,10<em>size(int)) 等同malloc(10</em>sizeof(int));</strong><br><strong>realloc(p,0); 等同于free</strong></p>\n</blockquote>\n<p>4:当缩小或者扩大内存时，一般不会对其进行移动，若无法扩大内存块，那么realloc会在别处分配新的内存块，然后把旧内存块的数据复制到新块中，并将旧块删除释放内存。</p>\n<p>realloc相关的的代码为:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;malloc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">out</span><span class=\"params\">(<span class=\"keyword\">int</span> *p ,<span class=\"keyword\">int</span> n)</span></span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span> ;i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,*(p+i));</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//申请4个字节的堆内存空间，未初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> * p = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">5</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>) <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    *p = <span class=\"number\">1</span>;</span><br><span class=\"line\">    *(p+<span class=\"number\">1</span>)  =<span class=\"number\">2</span>; </span><br><span class=\"line\">    p[<span class=\"number\">2</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">    p[<span class=\"number\">3</span>] = <span class=\"number\">4</span>;</span><br><span class=\"line\">    p[<span class=\"number\">4</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\">    out(p,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;===============\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//追加申请10个字节的内存空间，追加的空间也是未进行初始化的</span></span><br><span class=\"line\">     p = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">realloc</span>(p,<span class=\"number\">10</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>) <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    p[<span class=\"number\">6</span>] = <span class=\"number\">6</span>;</span><br><span class=\"line\">    *(p+<span class=\"number\">6</span>) = <span class=\"number\">7</span>;</span><br><span class=\"line\">    *(p+<span class=\"number\">7</span>) = <span class=\"number\">8</span>;</span><br><span class=\"line\">    *(p+<span class=\"number\">8</span>) = <span class=\"number\">9</span>;</span><br><span class=\"line\">    *(p+<span class=\"number\">9</span>) = <span class=\"number\">10</span>; </span><br><span class=\"line\">    out(p,<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    <span class=\"comment\">//free之后，将指针置为空</span></span><br><span class=\"line\">    p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>4:free函数</strong></p>\n<p><strong>free之后如果还有这块内存地址的话，此时这块内存归还给了系统，（可能这块内存还处于一个空闲状态）但是还是可以对其进行操作。里面的值短暂的会保留</strong></p>\n<p>free之后，申请内存的那个指针就会变成野指针(声明了，但是没有任何指向的指针)，有时候会出现野指针错误；<br>所以尽量在操作之后：将指针置为NULL<br>p=NULL；<br>注意：申请和释放是成对的，所以程序是不能进行多次free的，否则会崩溃的</p>\n<h4 id=\"常见的内存错误：\"><a href=\"#常见的内存错误：\" class=\"headerlink\" title=\"常见的内存错误：\"></a><strong>常见的内存错误：</strong></h4><p>错误<br>使用未分配成功的内存<br>避免方式：在使用内存之前检查指针是否为NULL；<br>引用分配成功但尚未初始化的内存<br>避免方式：赋予初值，即便是赋予零值也不可省略<br>内存分配成功并且已经初始化，但操作越过了内存的边界<br>避免：注意下表的使用不能超出边界<br>忘记释放内存，造成内存泄露<br>避免方式：申请内存的方式和释放内存的方式需要成双成对<br>释放内存之后却继续去使用这一块内存<br>避免方式：使用free内存之后，把指针置为NULL；</p>\n<p>内存错误的注意点：<br>指针消亡了，并不表示它所指向的内存会被自动释放,(在free之前，直接将指针设为NULL)；<br>内存释放了，并不代表指针会消亡或者成了NULL指针；(在free之后，指针并没有进行NULL设置)</p>\n<p>野指针：<br>野指针的形成是指针变量没有被初始化，任何指针变量刚被创建的时候不会自动成为NULL指针，它的缺省值是最忌的，它会乱指一气</p>\n<p>指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法内存</p>\n<p>free内存块之后，需要将指针设置为NULL，如果没有设置为NULL，也会出现“野指针”，它是指向“垃圾”内存的指针；</p>\n<p>多次free内存块，是会导致程序崩溃的。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTI0MDQxL2FydGljbGUvZGV0YWlscy81NDg5NzIwND9vcHNfcmVxdWVzdF9taXNjPSUyNTdCJTI1MjJyZXF1ZXN0JTI1NUZpZCUyNTIyJTI1M0ElMjUyMjE2MTUwODM4MzkxNjc4MDI2NjI1MzAxMiUyNTIyJTI1MkMlMjUyMnNjbSUyNTIyJTI1M0ElMjUyMjIwMTQwNzEzLjEzMDEwMjMzNC5wYyUyNTVGYWxsLiUyNTIyJTI1N0QmYW1wO3JlcXVlc3RfaWQ9MTYxNTA4MzgzOTE2NzgwMjY2MjUzMDEyJmFtcDtiaXpfaWQ9MCZhbXA7dXRtX21lZGl1bT1kaXN0cmlidXRlLnBjX3NlYXJjaF9yZXN1bHQubm9uZS10YXNrLWJsb2ctMn5hbGx+Zmlyc3RfcmFua192Mn5ob3RfcmFuay00LTU0ODk3MjA0LnBjX3NlYXJjaF9yZXN1bHRfYmVmb3JlX2pzJmFtcDt1dG1fdGVybT1jJUU1JThBJUE4JUU2JTgwJTgxJUU1JTg2JTg1JUU1JUFEJTk4JUU1JTg4JTg2JUU5JTg1JThE\">https://blog.csdn.net/qq_29924041/article/details/54897204?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161508383916780266253012%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161508383916780266253012&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-4-54897204.pc_search_result_before_js&amp;utm_term=c%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D</span></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/06/3.6%E4%B8%BA%E4%BA%86%E8%82%9D%E5%91%A8%E6%8A%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/",
            "url": "http://example.com/2021/03/06/3.6%E4%B8%BA%E4%BA%86%E8%82%9D%E5%91%A8%E6%8A%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/",
            "title": "横向联邦学习",
            "date_published": "2021-03-06T05:47:32.026Z",
            "content_html": "<h4 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h4><p>横向联邦学习也称为按样本划分的联邦学习，可以应用于联邦学习的各个参与方的数据集有相同的特征空间和不同的样本空间的场景，类似于再表格视图中对数据进行水平划分的情况。</p>\n<p>举例来说，两个地区的城市商业银行可能在各自的区域拥有非常不同的客户群体，所以他们的客户交集非常小，他们的数据集有不同的样本id。然而，他们的业务非常相似，因此他们的数据集的特征空间是相同的。这两家可以联合起来进行横向联邦学习以构建更好的风控模型。</p>\n<p>关于横向联邦学习系统的安全性的定义，我们通常假设一个横向联邦学习系统的参与方都是诚实的，需要防范的对象是一个诚实但好奇的聚合服务器。即通常假设只有服务器才能使得数据参与方的隐私安全受到威胁。</p>\n<p>以下是一些已提出的学习方法：</p>\n<p>参与方独立地训练模型并只分享参数更新的子集，这是横向联邦学习的一种特殊形式。</p>\n<p>在联邦学习框架下对用户模型更新或者对梯度信息进行安全聚合。</p>\n<p>适用于模型参数聚合的加法同态加密，能够防御联邦学习系统里的中央服务器窃取模型信息或者数据隐私。</p>\n<p>还有一种叫做深度梯度压缩的压缩方法，能够大幅度降低在大规模分布式训练中需要的通信宽带。</p>\n<p>甚至，另一种考虑了恶意用户的安全模型也被提出，这带来了联邦学习新的安全挑战。当联邦学习训练结束时，聚合模型和整个模型的参数都会暴露给所有的参与方。</p>\n<h4 id=\"横向联邦学习架构\"><a href=\"#横向联邦学习架构\" class=\"headerlink\" title=\"横向联邦学习架构\"></a>横向联邦学习架构</h4><h5 id=\"客户-服务器构架\"><a href=\"#客户-服务器构架\" class=\"headerlink\" title=\"客户-服务器构架\"></a>客户-服务器构架</h5><p>由于资料的缺失，这一部分先不讨论。</p>\n<h5 id=\"对等网络架构\"><a href=\"#对等网络架构\" class=\"headerlink\" title=\"对等网络架构\"></a>对等网络架构</h5><p>在该架构下，不存在中央服务器或者协调方。在这种架构中，横向联邦学习系统的K个参与方或者分布式训练方。每一个训练方负责只使用本地数据来训练同一个机器学习模型，此外，训练方们使用安全链路在相互之间传递模型参数信息。为了保证任意两方之间的通信安全，需要使用例如基于公共密钥的加密方法等安全措施。</p>\n<p>由于对等网络架构中不存在中央服务器，训练方必须提前商定发送和接受模型参数信息的顺序，主要有两个方法可以达到这个目的：</p>\n<ol>\n<li>循环传输</li>\n</ol>\n<p>训练方被组织成一条链。第一个训练方将当前的模型参数发送给它的下一个训练方。该训练方接受来自上游的模型参数后，将使用来自本地数据集的小批量数据更新收到的模型参数。之后，它将更新后的模型参数传输给下一个训练方。这一过程将被持续重复，直到模型参数收敛或达到允许的组大训练时间。</p>\n<p>  2.随机传输</p>\n<p>第k个训练方选取i，并将模型参数发送给训练方i。当第i个训练方收到来自第i个训练方的模型参数后，它将使用来自本地数据集的数据的<strong>mini-batch</strong>更新收到的模型参数。之后，第i个训练方选一个j，并将自己的模型参数发送给训练方j。这一过程将会重复，直到K个训练方同意模型参数收敛或达到允许的最大训练时间。这种方法叫做Gossip学习。</p>\n<p>与客户-服务器相比，对等网络架构的一个明显优点便是除去了中央服务器，而这类服务器在一些实际应用中可能难以获得或建立。但这一特性，也可能带来一些坏处，例如在循环传输模式中，由于没有中央服务器，权重参数并不分批量更新而是连续更新,这将导致训练模型耗费更多的时间。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/05/3.4%E7%9A%84%E6%84%9F%E6%83%B3/",
            "url": "http://example.com/2021/03/05/3.4%E7%9A%84%E6%84%9F%E6%83%B3/",
            "title": "怎么说呢，有点沉不下心来",
            "date_published": "2021-03-04T16:06:53.385Z",
            "content_html": "<p>又是无聊的一天，上午两节水课（大物老师太菜了，鬼都不想听）。哦，对，上午还看了一下Java，挺难的，看不太懂，毕竟没有咋实践过。继续看吧，看总比不看好。</p>\n<p>然后下午睡到三点多钟，爬起来学了一下博客做了点小功能，雪花呀，代码雨呀，有教程还是挺简单的，现在主要是在搞图标的问题，找也不好找，明天接着看一下吧。</p>\n<p>然后打了两把排位，都赢了（鳄鱼）。上单霸主。</p>\n<p>晚上写了一下博客，主要是工作室的任务还没完成，天天学这学那。所以写了点安全多方计算。算是理解深了点吧。</p>\n<p>over。</p>\n<p>明天体育课，，，操，，浪费老子100权重。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/04/%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97%E7%9A%84%E5%88%9D%E8%AE%A4%E8%AF%86/",
            "url": "http://example.com/2021/03/04/%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97%E7%9A%84%E5%88%9D%E8%AE%A4%E8%AF%86/",
            "title": "安全多方计算的初认识",
            "date_published": "2021-03-04T10:05:43.931Z",
            "content_html": "<h5 id=\"安全多方计算\"><a href=\"#安全多方计算\" class=\"headerlink\" title=\"安全多方计算\"></a>安全多方计算</h5><p>安全多方计算最初是针对一个安全两方计算问题，即所谓的“百万富翁问题”而被提出的（姚期智）。在安全多方计算中，目的是协同地从没一方的隐私输入中计算函数的结果。而不用将这些输入展示给其他方。安全多方计算告诉我们，对于任何功能需求，我们都可以在不必显示除了输出以外的前提下计算它。</p>\n<p>为了了解安全多方计算，让我们先看两个场景例子: </p>\n<p>（1）Alice认为她的了某种遗传疾病，想验证自己的想法。正好她知道Bob有一个关于疾病的DNA模型的数据库。如果她把自己的DNA样品寄给Bob，那么Bob可以给出她的DNA的诊断结果。但是Alice又不想别人知道，这是她的隐私。所以，她请求Bob帮忙诊断自己DNA的方式是不可行的。因为这样Bob就知道了她的DNA及相关私人信息。</p>\n<p>（2）两个金融组织计划为了共同的利益决定互相合作一个项目。每个组织都想自己的需求获得满足。然而，他们的需求都是他们自己专有的数据，没人愿意透露给其他方，甚至是“信任”的第三方。那么他们如何在保护数据私密性的前提下合作项目呢？</p>\n<blockquote>\n<p><strong>当前，解决上述问题的策略是假设有可信任的服务提供者或是假设存在可信任的第三方。但是在目前多变和充满恶意的环境中，这是极具风险的。因此，可以支持联合计算并保护参与者私密的协议变的日益重要。</strong></p>\n</blockquote>\n<p><img data-src=\"https://i.imgtg.com/2023/03/09/Y9BfS.png\"></p>\n<p>证明安全多方学习计算协议是安全的标准方法为仿真范式。为了证明安全多方计算协议再仿真范式下可以抵御使t方腐败的敌手，需要构建一个模拟器，当给定t个勾结放的输入输出时，生成t个交互序列，从而使生成的交互序列与实际协议中生成的交互序列之间无法区分。</p>\n<p>通常情况下，安全多方计算能够通过三种不同的框架来实现：不经意传输、秘密共享和阈值同态加密。</p>\n<blockquote>\n<p>从某种程度上讲，不经意传输协议和阈值同态加密方法都使用了秘密共享的思想，这可能就是为什么秘密共享被广泛认为是安全多方计算的核心。</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/09/Y9UBN.png\" alt=\"image-20210304204437481\"></p>\n</blockquote>\n<h5 id=\"同态加密\"><a href=\"#同态加密\" class=\"headerlink\" title=\"同态加密\"></a>同态加密</h5><p>同态加密方法H是一种通过对相关密文进行有效的操作（不需获知解密密钥），从而允许在加密内容上进行特定代数运算的加密方法。</p>\n<p>…….</p>\n<p>这篇先不深入解释同态加密。</p>\n<p>over</p>\n<p>额，图片好像上传不上去（不会）。先就这样吧，反正图片也就是一些解释和公式。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/03/3.3%E7%9A%84%E6%84%9F%E6%83%B3/",
            "url": "http://example.com/2021/03/03/3.3%E7%9A%84%E6%84%9F%E6%83%B3/",
            "title": "无题",
            "date_published": "2021-03-03T15:46:09.789Z",
            "content_html": "<h5 id=\"写这个只是为了回忆一下今天的所作所为，起到一个警醒作用吧！\"><a href=\"#写这个只是为了回忆一下今天的所作所为，起到一个警醒作用吧！\" class=\"headerlink\" title=\"写这个只是为了回忆一下今天的所作所为，起到一个警醒作用吧！\"></a>写这个只是为了回忆一下今天的所作所为，起到一个警醒作用吧！</h5><ul>\n<li>今天就两节课，一节微积分，一节离散。</li>\n</ul>\n<p>微积分还算好好听了，这个老师（高中喜）讲的课还算听得下去，感觉女的数学老师教学水平就那样，或者说不能激发我的兴趣把。还是得好好学，没办法，虽然感觉上了大学只想打游戏，但还是有自制力的。</p>\n<p>离散就真鸡巴水，难怪王静（大一上计算机导论的老师）都可以教。看了两节课java（沉默王二），也没看进去多少。</p>\n<ul>\n<li>晚上打了两三个小时游戏，输（我carry）多赢（队友carry）少。当然有点不尽兴，不过也没有办法。</li>\n<li>明天（星期四）似乎也是两节没啥意思的课（大物和思修）。突然想看python了，感觉挺容易的，java还得多学学，而且C都不怎么会。</li>\n<li>慢慢学吧。</li>\n<li>0：08</li>\n<li>over</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/03/static/",
            "url": "http://example.com/2021/03/03/static/",
            "title": "C中static的运用",
            "date_published": "2021-03-03T11:57:00.150Z",
            "content_html": "<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h5 id=\"1-局部变量\"><a href=\"#1-局部变量\" class=\"headerlink\" title=\"1.局部变量\"></a>1.局部变量</h5><p>定义在函数内部的变量（不加static修饰）属于这个范畴。编译器一般不对普通局部变量进行初始化，也就是说它的值在初始时是不确定的，除非对其显式赋值（啥意思？）。</p>\n<blockquote>\n<p>普通局部变量存储于进程栈空间，使用完毕会立即释放。</p>\n</blockquote>\n<p>静态局部变量使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。</p>\n<p>小程序试一试（大一上期末考过类似的）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......自己臆想吧</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n=<span class=\"number\">10</span></span><br><span class=\"line\">n++=<span class=\"number\">11</span></span><br><span class=\"line\">--------------------</span><br><span class=\"line\"><span class=\"keyword\">static</span> n=<span class=\"number\">10</span></span><br><span class=\"line\">n++=<span class=\"number\">11</span></span><br><span class=\"line\">--------------------</span><br><span class=\"line\">n=<span class=\"number\">10</span></span><br><span class=\"line\">n++=<span class=\"number\">11</span></span><br><span class=\"line\">--------------------</span><br><span class=\"line\"><span class=\"keyword\">static</span> n=<span class=\"number\">11</span></span><br><span class=\"line\">n++=<span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n\n<p>由此可见，静态局部变量的效果跟全局变量有得一拼，而且位于函数体内部，就有利于程序的模块化了。</p>\n<h5 id=\"2-全局变量\"><a href=\"#2-全局变量\" class=\"headerlink\" title=\"2.全局变量\"></a>2.全局变量</h5><p>全局变量定义在函数体外部，在全局数据区分配存储空间，且编译器会自动对其初始化。</p>\n<p>普通全局变量对整个工程可见，其他文件可以使用<strong>extern</strong>外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量）。</p>\n<p>静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。</p>\n<blockquote>\n<p>在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。</p>\n</blockquote>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数。其特性如下： </p>\n<ul>\n<li>静态函数只能在声明它的文件中可见，其他文件不能引用该函数</li>\n<li>不同的文件可以使用相同名字的静态函数，互不影响</li>\n</ul>\n<blockquote>\n<p><em><strong>非</strong></em>静态函数可以在另一个文件中直接引用，甚至不必使用extern声明</p>\n</blockquote>\n<p>非静态函数可以在另一个文件中直接引用，甚至不必使用extern声明： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* file1.c */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello from fun.\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    fun();</span><br><span class=\"line\">    fun1();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* file2.c */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello from static fun1.\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>gcc file1.c file2.c</code>编译时，错误报告如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/tmp/cc2VMzGR.o：在函数‘main’中： </span><br><span class=\"line\">static_fun.c:(.text+<span class=\"number\">0x20</span>)：对‘fun1’未定义的引用</span><br><span class=\"line\">collect2: error: ld returned <span class=\"number\">1</span> <span class=\"built_in\">exit</span> status</span><br></pre></td></tr></table></figure>\n\n<p>修改文件，不使用static修饰符，可在另一文件中引用该函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* file1.c */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello from fun.\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* file2.c */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    fun();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同样使用 <code>gcc file1.c file2.c</code>编译，编译通过，运行结果如下： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; % ./a.out </span><br><span class=\"line\">hello from fun.</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>写下来感觉static还是很有用的（虽然我没用过），能够将代码模块化，达到所谓的松耦合。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/",
            "url": "http://example.com/2021/03/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/",
            "title": "我的第一篇博客",
            "date_published": "2021-03-03T05:02:28.386Z",
            "content_html": "<p><em>斜体文本</em><br>\n<em>斜体文本</em><br>\n<strong>粗体文本</strong><br>\n<strong>粗体文本</strong><br>\n<em><strong>粗斜体文本</strong></em><br>\n<em><strong>粗斜体文本</strong></em><br>\n<s> BAIDU.COM</s></p>\n<ol>\n<li>第一项：</li>\n</ol>\n<ul>\n<li>第一项嵌套的第一个元素</li>\n<li>第一项嵌套的第二个元素</li>\n</ul>\n<ul>\n<li>第三项</li>\n</ul>\n<blockquote>\n<p>最外层</p>\n<blockquote>\n<p>第一层嵌套</p>\n<blockquote>\n<p>第二层嵌套</p>\n</blockquote>\n</blockquote>\n</blockquote>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/02/hello-world/",
            "url": "http://example.com/2021/03/02/hello-world/",
            "title": "Hello World",
            "date_published": "2021-03-02T09:02:28.329Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}