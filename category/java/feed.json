{
    "version": "https://jsonfeed.org/version/1",
    "title": "hc‘s blog • All posts by \"java\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/08/28/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F/",
            "url": "http://example.com/2022/08/28/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F/",
            "title": "Spring依赖注入有几种？各自有什么优缺点？",
            "date_published": "2022-08-28T06:02:50.667Z",
            "content_html": "<p>IoC 和 DI 是 Spring 中最重要的两个概念，其中 IoC 为控制反转的思想，而 DI 依赖注入是 IoC 的具体实现。</p>\n<hr>\n<h4 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\">#</a> 概述</h4>\n<p>在 Spring 中实现依赖注入的常见方式有以下 3 种：</p>\n<ol>\n<li><strong>属性注入（Field Injection）；</strong></li>\n<li><strong>Setter 注入（Setter Injection）；</strong></li>\n<li><strong>构造方法注入（Constructor Injection）。</strong></li>\n</ol>\n<h4 id=\"属性注入\"><a class=\"markdownIt-Anchor\" href=\"#属性注入\">#</a> 属性注入</h4>\n<p>属性注入是日常开发中使用最多的一种注入方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 属性对象</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">add</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userService.add(username, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h5>\n<p><strong>属性注入最大的优点就是实现简单、使用简单</strong>，只需要给变量上添加一个注解（@Autowired），就可以在不 new 对象的情况下，直接获得注入的对象了（这就是 DI 的功能和魅力所在），所以它的优点就是使用简单。</p>\n<h5 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点</h5>\n<p>属性注入虽然使用简单，但是也存在很多问题，甚至编译器 Idea 都会提醒你 “不建议使用此注入方式”，Idea 的提示信息如下：</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/10/Y8uCq.png\" alt=\"image-20220827130311145\"></p>\n<p>属性注入的缺点主要包含以下 3 个：</p>\n<ol>\n<li>功能性问题：无法注入一个不可变的对象（final 修饰的对象）；</li>\n<li>通用性问题：只能适应于 IoC 容器；</li>\n<li>设计原则问题：更容易违背单一设计原则。</li>\n</ol>\n<h4 id=\"setter注入\"><a class=\"markdownIt-Anchor\" href=\"#setter注入\">#</a> Setter 注入</h4>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Setter 注入</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserService</span><span class=\"params\">(UserService userService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userService = userService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">add</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userService.add(username, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"优点-2\"><a class=\"markdownIt-Anchor\" href=\"#优点-2\">#</a> 优点</h5>\n<p>完全符合单一职责的设计原则，因为每一个 Setter 只针对一个对象。</p>\n<h5 id=\"缺点-2\"><a class=\"markdownIt-Anchor\" href=\"#缺点-2\">#</a> 缺点</h5>\n<ol>\n<li>不能注入不可变对象（final 修饰的对象）；</li>\n<li>注入的对象可被修改。</li>\n</ol>\n<h4 id=\"构造方法注入\"><a class=\"markdownIt-Anchor\" href=\"#构造方法注入\">#</a> 构造方法注入</h4>\n<p><strong>构造方法注入是 Spring 官方从 4.x 之后推荐的注入方式</strong>，它的实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造方法注入</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">(UserService userService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userService = userService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">add</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userService.add(username, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，<strong>如果当前的类中只有一个构造方法，那么 @Autowired 也可以省略</strong>，所以以上代码还可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造方法注入</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">(UserService userService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userService = userService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">add</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userService.add(username, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"优点-3\"><a class=\"markdownIt-Anchor\" href=\"#优点-3\">#</a> 优点</h5>\n<ol>\n<li>可注入不可变对象；</li>\n<li>注入对象不会被修改；</li>\n<li>注入对象会被完全初始化；</li>\n<li>通用性更好。</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/",
            "url": "http://example.com/2022/08/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/",
            "title": "并发编程入门（1）：可见性、原子性和有序性",
            "date_published": "2022-08-27T13:07:03.041Z",
            "content_html": "<h4 id=\"并发程序幕后的故事\"><a href=\"#并发程序幕后的故事\" class=\"headerlink\" title=\"并发程序幕后的故事\"></a>并发程序幕后的故事</h4><p>一个核心矛盾：cpu、内存、I/O设备的速度差异</p>\n<p>cpu的速度是内存的100倍，</p>\n<p>内存是I/O的100倍。</p>\n<p>而程序大部分语句要访问内存，有些还要访问I/O，所以程序整体的性能屈居于最慢的操作—读写I/O设备。单方面提高cpu性能是无效的。</p>\n<p>为了平衡这三者的速度差异，计算机体系结构，操作系统，编译程序都做出了贡献：</p>\n<ol>\n<li>cpu增加了缓存，以均衡与内存的速度差异；</li>\n<li>操作系统增加了进程、线程，以分时复用cpu，以均衡cpu与I/O设备的速度差异；</li>\n<li>编译程序优化指令执行次序，使得缓存能够得到更加合理的利用。</li>\n</ol>\n<p>但是，并发程序很多问题的根源也在这里。</p>\n<h4 id=\"源头之一：缓存导致的可见性问题\"><a href=\"#源头之一：缓存导致的可见性问题\" class=\"headerlink\" title=\"源头之一：缓存导致的可见性问题\"></a>源头之一：缓存导致的可见性问题</h4><p>一个线程对共享变量的修改，另外一个线程能够立即看到，我们称之为可见性。</p>\n<p>在单核时代，cpu缓存与内存数据的一致性很好解决。</p>\n<p>在多核时代，每个cpu都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的“坑”。</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/09/Y9qxK.png\" alt=\"image-20220826144959349\"></p>\n<h4 id=\"源头之二：线程切换带来的原子性问题\"><a href=\"#源头之二：线程切换带来的原子性问题\" class=\"headerlink\" title=\"源头之二：线程切换带来的原子性问题\"></a>源头之二：线程切换带来的原子性问题</h4><p>由于IO太慢，早期的操作系统就发明了多进程，即使在单核的cpu上，我们也可以一边听歌一边写代码。</p>\n<p>java并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count += 1，至少需要三条 CPU 指令。</p>\n<p>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</p>\n<p>指令 2：之后，在寄存器中执行 +1 操作；</p>\n<p>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</p>\n<p>操作系统做任务切换，可以发生在任何一条CPU 指令执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/09/Y95Ja.png\" alt=\"image-20220826154247317\"></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E6%B5%AE%E7%82%B9%E5%9E%8B%E8%A1%A8%E7%A4%BA%E9%87%91%E9%A2%9D/",
            "url": "http://example.com/2022/08/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E6%B5%AE%E7%82%B9%E5%9E%8B%E8%A1%A8%E7%A4%BA%E9%87%91%E9%A2%9D/",
            "title": "为什么不能用浮点型表示金额",
            "date_published": "2022-08-22T07:26:44.498Z",
            "content_html": "<p>由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p>\n<p>建议使用BigDecimal或者Long（单位为分）来表示金额。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/22/%E7%B1%BB%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/",
            "url": "http://example.com/2022/08/22/%E7%B1%BB%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/",
            "title": "类变量，成员变量和局部变量",
            "date_published": "2022-08-22T07:26:44.492Z",
            "content_html": "<p>java 中共有三种变量，分别是类变量，成员变量和局部变量。分别存放在 jvm 的方法区、堆内区、和栈内区中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Variables</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 类变量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 成员变量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 局部变量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> c</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>a 是类变量，b 是成员变量，而变量 c 和 d 是局部变量。</p>\n<p>因为只有共享变量才会遇到并发问题，所以，变量 a 和 b 是共享变量，变量 c 和 d 是非共享变量。所以如果遇到多线程场景，对于变量 a 和 b 的操作是需要考虑线程安全的，而对于线程 c 和 d 的操作是不需要考虑线程安全的。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/22/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/",
            "url": "http://example.com/2022/08/22/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/",
            "title": "构造函数",
            "date_published": "2022-08-22T07:26:44.485Z",
            "content_html": "<p>主要用来创建对象时初始化对象，即为对象那个 成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 矩形</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> length, <span class=\"keyword\">int</span> width)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.length = length;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span> <span class=\"params\">(String []args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用构造函数创建对象</span></span><br><span class=\"line\">        Rectangle rectangle = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">10</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。</p>\n<p>构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。</p>\n<p>构造器的函数名称必须和它所属的类的名称相同。它承担着初始化对象数据成员的任务。</p>\n<p>如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如int -&gt; 0，Integer -&gt; null。</p>\n<p>如果在编写一个可实例化的类时没有专门编写构造函数，默认情况下，一个Java类中会自动生成一个默认无参构造函数。默认构造函数一般会把成员变量的值初始化为默认值，如int -&gt; 0，Integer -&gt; null。</p>\n<p>但是，如果我们手动在某个类中定义了一个有参数的构造函数，那么这个默认的无参构造函数就不会自动添加了。需要手动创建！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 矩形</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> length, <span class=\"keyword\">int</span> width)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.length = length;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 无参构造函数</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/22/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/",
            "url": "http://example.com/2022/08/22/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/",
            "title": "方法重写和重载",
            "date_published": "2022-08-22T07:26:44.476Z",
            "content_html": "<p>重载：指的是在同一个类中，多个函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p>\n<p>重写：指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重载</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;woof &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//overloading method</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bark</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;num; i++)</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;woof &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定具体哪个bark方法被调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重载</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;woof &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hound</span> <span class=\"keyword\">extends</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sniff</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sniff &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;bowl&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OverridingTest</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span></span>&#123;</span><br><span class=\"line\">        Dog dog = <span class=\"keyword\">new</span> Hound();</span><br><span class=\"line\">        dog.bark();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bowl</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中，我们分别在父类、子类中都定义了bark方法，并且他们都是无参方法，所以我们就说这种情况就是方法重写。即子类Hound重写了父类Gog中的bark方法。</p>\n<p>在测试的main方法中，<code>dog</code>对象被定义为<code>Dog</code>类型。</p>\n<p>在编译期，编译器会检查Dog类中是否有可访问的<code>bark()</code>方法，只要其中包含<code>bark（）</code>方法，那么就可以编译通过。</p>\n<p>在运行期，<code>Hound</code>对象被<code>new</code>出来，并赋值给<code>dog</code>变量，这时，JVM是明确的知道<code>dog</code>变量指向的其实是<code>Hound</code>对象的引用。所以，当<code>dog</code>调用<code>bark()</code>方法的时候，就会调用<code>Hound</code>类中定义的<code>bark（）</code>方法。这就是所谓的动态多态性。</p>\n<p>方法重写需满足以下条件</p>\n<p>1、参数列表必须完全与被重写方法的相同； 2、返回类型必须完全与被重写方法的返回类型相同； 3、访问级别的限制性一定不能比被重写方法的强； 4、访问级别的限制性可以比被重写方法的弱； 5、重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常 6、重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明） 7、不能重写被标示为final的方法； 8、如果不能继承一个方法，则不能重写这个方法。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/21/%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2022/08/21/%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/",
            "title": "多继承问题",
            "date_published": "2022-08-21T09:04:26.664Z",
            "content_html": "<p>Java 中支持一个类同时实现多个接口，但是不支持同时继承多个类。但是这个问题在 Java 8 之后也不绝对了。</p>\n<p>一个类，只有一个父类的情况，我们叫做单继承。而一个类，同时有多个父类的情况，叫做多继承。</p>\n<p>在 Java 中，一个类，只能通过 extends 关键字继承一个类，不允许多继承。但是，多继承在其他的面向对象语言中是有可能支持的。</p>\n<p>像 C++ 就是支持多继承的，主要是因为编程的过程是对现实世界的一种抽象，而现实世界中，确实存在着需要多继承的情况。比如维基百科中关于多继承举了一个例子：</p>\n<p>例如，可以创造一个 “哺乳类动物” 类别，拥有进食、繁殖等的功能；然后定义一个子类型 “猫”，它可以从父类继承上述功能。</p>\n<p>但是，&quot;猫&quot; 还可以作为 &quot;宠物&quot; 的子类，拥有一些宠物独有的能力。</p>\n<p>所以，有些面向对象语言是支持多重继承的。</p>\n<p>但是，多年以来，多重继承一直都是一个敏感的话题，反对者指它增加了程序的复杂性与含糊性。</p>\n<h3 id=\"菱形继承问题\"><a class=\"markdownIt-Anchor\" href=\"#菱形继承问题\">#</a> 菱形继承问题</h3>\n<p>假设我们有类 B 和类 C，它们都继承了相同的类 A。另外我们还有类 D，类 D 通过多重继承机制继承了类 B 和类 C。</p>\n<p><img data-src=\"https://i.imgtg.com/2023/03/10/Y83ic.png\" alt=\"img\"></p>\n<p>这时候，因为 D 同时继承了 B 和 C，并且 B 和 C 又同时继承了 A，那么，D 中就会因为多重继承，继承到两份来自 A 中的属性和方法。</p>\n<p>这时候，在使用 D 的时候，如果想要调用一个定义在 A 中的方法时，就会出现歧义。</p>\n<p>因为这样的继承关系的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。</p>\n<p>而 C++ 为了解决菱形继承问题，又引入了<strong>虚继承</strong>。</p>\n<p>因为支持多继承，引入了菱形继承问题，又因为要解决菱形继承问题，引入了虚继承。而经过分析，人们发现我们其实真正想要使用多继承的情况并不多。</p>\n<p>所以，在 Java 中，不允许 “实现多继承”，即一个类不允许继承多个父类。但是 Java 允许 “声明多继承”，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现（Java 8 以前），这就避免了 C++ 中多继承的歧义问题。</p>\n<p>但是，Java 不支持多继承，在 Java 8 中支持了默认函数（default method ）之后就不那么绝对了。</p>\n<p>虽然我们还是没办法使用 extends 同时继承多个类，但是因为有了默认函数，我们有可能通过 implements 从多个接口中继承到多个默认函数，那么，又如何解决这种情况带来的菱形继承问题呢？</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/08/19/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/",
            "url": "http://example.com/2022/08/19/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/",
            "title": "java中的多态",
            "date_published": "2022-08-19T07:57:49.921Z",
            "content_html": "<p>同一操作作用于不同的对象，可以有不同的解释，产生不同的结果。</p>\n<p>java中的多态是一种运行期的状态。满足三个条件：</p>\n<ul>\n<li>有类继承或者接口实现</li>\n<li>子类要重写父类的方法</li>\n<li>父类的引用指向子类的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        sout(<span class=\"string\">&quot;im Parent&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span></span>&#123;<span class=\"comment\">// 1.有类继承或者接口实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">// 2.子类要重写父类的方法</span></span><br><span class=\"line\">        sout(<span class=\"string\">&quot;im Son&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span></span>&#123;<span class=\"comment\">// 1.有类继承或者接口实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">// 2.子类要重写父类的方法</span></span><br><span class=\"line\">        sout(<span class=\"string\">&quot;im Daughter&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Parent p = <span class=\"keyword\">new</span> Son(); <span class=\"comment\">//3.父类的引用指向子类的对象</span></span><br><span class=\"line\">        Parent p1 = <span class=\"keyword\">new</span> Daughter(); <span class=\"comment\">//3.父类的引用指向子类的对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样，就实现了多态，同样是Parent类的实例，p.call 调用的是Son类的实现、p1.call调用的是Daughter的实现。</p>\n<p>有人说，你自己定义的时候不就已经知道p是son，p1是Daughter了么。但是，有些时候你用到的对象并不都是自己声明的。</p>\n<p>比如Spring 中的IOC出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。</p>\n<blockquote>\n<p>IOC，是Ioc—Inversion of Control 的缩写，中文翻译成“控制反转”，它是一种设计思想，意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p>\n<p>换句话说当我们使用Spring框架的时候，对象是Spring容器创建出来并由容器进行管理，我们只需要使用就行了。</p>\n</blockquote>\n",
            "tags": []
        }
    ]
}