{
    "version": "https://jsonfeed.org/version/1",
    "title": "hc‘s blog • All posts by \"c语言\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/03/11/c%E7%9A%84const/",
            "url": "http://example.com/2021/03/11/c%E7%9A%84const/",
            "title": "const",
            "date_published": "2021-03-11T04:43:15.593Z",
            "content_html": "<p>const 修饰的数据类型是指常类型，常类型的变量或对象的对象的值是不能被更新的。</p>\n<p>const 推出的初始目的，正是为了取代预编译指令，消除他的缺点，同时继承它的优点。</p>\n<h5 id=\"主要作用\"><a href=\"#主要作用\" class=\"headerlink\" title=\"主要作用\"></a>主要作用</h5><ol>\n<li>可以定义const常量，具有不可变性。例如：const int max = 100；max++会产生错误。</li>\n<li>便于进行类型检查，是编译器对处理内容有更多了解，消除了一些隐患。例如：void f（const int i）{…….}编译器就会知道i是一个常量，不允许修改；</li>\n<li>可以避免意义模糊的数字出现，同样可以很方便的进行参数的调整和修改。同宏定义一样。</li>\n<li>可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。</li>\n<li>可以节省空间，避免不必要的内存分配。如：</li>\n</ol>\n<p>#define PI 3.14159 //常量宏  　　</p>\n<p>const double <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9QaQ==\">Pi</span>=3.14159; //此时并未将Pi放入ROM中 ……  　　</p>\n<p>double i=Pi; //此时为Pi分配内存，以后不再分配！  　　</p>\n<p>double I=PI; //编译期间进行宏替换，分配内存　</p>\n<p>double j=Pi; //没有内存分配  　　</p>\n<p>double J=PI; //再进行宏替换，又一次分配内存！ </p>\n<p>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干份拷贝。</p>\n<h5 id=\"变量和常量\"><a href=\"#变量和常量\" class=\"headerlink\" title=\"变量和常量\"></a>变量和常量</h5><p>例：为什么下面的例子在使用一个const变量来初始化数组，ANSI C编译器会报告一个错误呢？</p>\n<p>const int n = 5；</p>\n<p>int a[n];</p>\n<p> 答案与分析：</p>\n<p>1）这个问题讨论的是“常量与“只读变量”的区别。常量，例如5， “abc”，等，肯定是只读的，因为常量是被编译器放在内存中的只读区域，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时长度必须是“常量” C99标准，数组下标可以用变量来表示），“只读变量”也是不可以的，“常量”不等于“不可变的变量”。但是在C++中，局部数组是可以使用变量作为其长度的。</p>\n<p>2）但是在标准C++中，这样定义的是一个常量，这种写法是对的。实际上，根据编译过程及内存分配ANSI C对数组的规定限制了它（实际上用GCC或VS2005编译以上代码，确实没有错误产生，也没有给出警告）。</p>\n<p>3）那么，在ANSI C中用什么来定义常量呢？答案是enum类型和#define宏，这两个都可以用来定义常量。</p>\n<p>。。。。。</p>\n<p>const 的用法还有很多，今天就先写到这里。</p>\n<p>有需要再添加吧。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/07/c%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/",
            "url": "http://example.com/2021/03/07/c%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/",
            "title": "C的动态内存分配",
            "date_published": "2021-03-07T02:13:23.228Z",
            "content_html": "<h4 id=\"内存分配的方式\"><a href=\"#内存分配的方式\" class=\"headerlink\" title=\"内存分配的方式\"></a>内存分配的方式</h4><ul>\n<li><strong>在静态存储区域中进行分配</strong></li>\n</ul>\n<p>​        内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量</p>\n<ul>\n<li><strong>在栈中进行分配</strong></li>\n</ul>\n<p>​        在执行函数时，函数内<strong>局部变量</strong>的存储单元都可以在栈上创建，函数执行结束时，这些存储但愿自动被释放。效率很高，但是分配的内存容量比较有限</p>\n<ul>\n<li><strong>在堆中进行分配</strong></li>\n</ul>\n<p>​        在堆上分配也称为动态内存分配：程序在运行的时候用malloc等函数申请任意多少的内存，程序员自己负责在何时用free释放内存。动态内存分配的生存期由我们自己决定，使用非常灵活，但是问题相对也比较多；注意：如果没有释放的话，很容易就会造成内存溢出，因为堆中的内存块是全局的，因此不会因为函数的调用而结束</p>\n<h4 id=\"动态内存分配中使用的函数：\"><a href=\"#动态内存分配中使用的函数：\" class=\"headerlink\" title=\"动态内存分配中使用的函数：\"></a><strong>动态内存分配中使用的函数：</strong></h4><p><strong>1:malloc函数:需要用到的头文件malloc.h</strong></p>\n<p>void *malloc(size_t size) //————–&gt;返回的是一个通用类型的指针，根据需要去进行强转；<br>功能：允许从空闲内存池中分配连续内存但不初始化<br>参数：size参数实际就是一个所需字节数的整数 malloc(20);<br>返回：若分配成功则返回一个指向该内存块的指针，在使用时可根据需要做强制类型转换，否则返回NULL（空指针）//需要判空</p>\n<p>free(p);//释放内存空间,将内存释放出来给系统；<br>free函数与malloc函数是成对出现的；<br>申请malloc的时候尽量去给它进行一下初始化，防止后面出现一些不确定性的东西；<br>malloc的生命周期：只要没有调用free这个函数，进程没有结束，那么此时，这个函数的生命周期就会一直存在在内存中；它是存放在堆空间中的，它不会因为你去函数调用的结束自动去释放，堆当中的内存是全局的。<br>如：int <em>p = (int</em> )malloc(n<em>sizeof(int)); //在<strong>空闲内存池</strong>中分配连续内存n</em>sizeof(int)个字节的<strong>堆内存空间</strong></p>\n<p>malloc的相关实例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;malloc.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">out</span><span class=\"params\">(<span class=\"keyword\">int</span> *p,<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,*(p+i));</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;---------------\\n&quot;</span>);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;please input one number:&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"comment\">//申请</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"comment\">//内存申请成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        out(p,n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            *(p+i)=i*i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        out(p,n);</span><br><span class=\"line\">        <span class=\"comment\">//释放掉堆内存</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//内存申请失败</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;malloc is NULL!\\n&quot;</span>);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2:calloc函数:需要用到的头文件stdlib.h</strong></p>\n<p>void <em>colloc(size_t num_elements,size_t element_size);<br>功能:功能同malloc是一样的，但是作*<em>初始化</em></em><br>参数:num_elements是所需的元素的数量，element_size是每个元素的字节数<br>返回:同malloc函数一样<br>也是需要与free(p)进行对称使用<br>calloc相关代码如下所示:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;please input one number:&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">calloc</span>(n,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,*(p+i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;calloc error\\n&quot;</span>);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3: realloc函数:需要用到的头文件(stdlib.h),动态扩大缩小申请的内存</strong></p>\n<p>void *realloc(void *ptr,size_t new_size);<br>功能:在指针ptr指向的内存基础上扩大或者缩小内存<br>参数:ptr是指向先前通过<strong>malloc,calloc和realloc函数后分配的内存块的指针</strong>，new_size是内存块的新尺寸，可能大于或者小于原有内存尺寸；这个是追加到new_size的新的内存<br>realloc在C语言中也被称为动态数组；<br>realloc函数使用的注意点:<br>1:当扩展内存的时候，不会对添加进内存块的字节进行初始化<br>2:若不能调整内存则返回NULL，但原有内存中的数据是不会发生改变的<br>3:<strong>若第一个参数为NULL那么功能 等同与malloc函数，若第二个参数为0,那么会释放调用内存块</strong></p>\n<blockquote>\n<p><strong>realloc(NULL,10<em>size(int)) 等同malloc(10</em>sizeof(int));</strong><br><strong>realloc(p,0); 等同于free</strong></p>\n</blockquote>\n<p>4:当缩小或者扩大内存时，一般不会对其进行移动，若无法扩大内存块，那么realloc会在别处分配新的内存块，然后把旧内存块的数据复制到新块中，并将旧块删除释放内存。</p>\n<p>realloc相关的的代码为:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;malloc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">out</span><span class=\"params\">(<span class=\"keyword\">int</span> *p ,<span class=\"keyword\">int</span> n)</span></span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span> ;i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,*(p+i));</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//申请4个字节的堆内存空间，未初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> * p = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">5</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>) <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    *p = <span class=\"number\">1</span>;</span><br><span class=\"line\">    *(p+<span class=\"number\">1</span>)  =<span class=\"number\">2</span>; </span><br><span class=\"line\">    p[<span class=\"number\">2</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">    p[<span class=\"number\">3</span>] = <span class=\"number\">4</span>;</span><br><span class=\"line\">    p[<span class=\"number\">4</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\">    out(p,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;===============\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//追加申请10个字节的内存空间，追加的空间也是未进行初始化的</span></span><br><span class=\"line\">     p = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">realloc</span>(p,<span class=\"number\">10</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>) <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    p[<span class=\"number\">6</span>] = <span class=\"number\">6</span>;</span><br><span class=\"line\">    *(p+<span class=\"number\">6</span>) = <span class=\"number\">7</span>;</span><br><span class=\"line\">    *(p+<span class=\"number\">7</span>) = <span class=\"number\">8</span>;</span><br><span class=\"line\">    *(p+<span class=\"number\">8</span>) = <span class=\"number\">9</span>;</span><br><span class=\"line\">    *(p+<span class=\"number\">9</span>) = <span class=\"number\">10</span>; </span><br><span class=\"line\">    out(p,<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    <span class=\"comment\">//free之后，将指针置为空</span></span><br><span class=\"line\">    p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>4:free函数</strong></p>\n<p><strong>free之后如果还有这块内存地址的话，此时这块内存归还给了系统，（可能这块内存还处于一个空闲状态）但是还是可以对其进行操作。里面的值短暂的会保留</strong></p>\n<p>free之后，申请内存的那个指针就会变成野指针(声明了，但是没有任何指向的指针)，有时候会出现野指针错误；<br>所以尽量在操作之后：将指针置为NULL<br>p=NULL；<br>注意：申请和释放是成对的，所以程序是不能进行多次free的，否则会崩溃的</p>\n<h4 id=\"常见的内存错误：\"><a href=\"#常见的内存错误：\" class=\"headerlink\" title=\"常见的内存错误：\"></a><strong>常见的内存错误：</strong></h4><p>错误<br>使用未分配成功的内存<br>避免方式：在使用内存之前检查指针是否为NULL；<br>引用分配成功但尚未初始化的内存<br>避免方式：赋予初值，即便是赋予零值也不可省略<br>内存分配成功并且已经初始化，但操作越过了内存的边界<br>避免：注意下表的使用不能超出边界<br>忘记释放内存，造成内存泄露<br>避免方式：申请内存的方式和释放内存的方式需要成双成对<br>释放内存之后却继续去使用这一块内存<br>避免方式：使用free内存之后，把指针置为NULL；</p>\n<p>内存错误的注意点：<br>指针消亡了，并不表示它所指向的内存会被自动释放,(在free之前，直接将指针设为NULL)；<br>内存释放了，并不代表指针会消亡或者成了NULL指针；(在free之后，指针并没有进行NULL设置)</p>\n<p>野指针：<br>野指针的形成是指针变量没有被初始化，任何指针变量刚被创建的时候不会自动成为NULL指针，它的缺省值是最忌的，它会乱指一气</p>\n<p>指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法内存</p>\n<p>free内存块之后，需要将指针设置为NULL，如果没有设置为NULL，也会出现“野指针”，它是指向“垃圾”内存的指针；</p>\n<p>多次free内存块，是会导致程序崩溃的。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTI0MDQxL2FydGljbGUvZGV0YWlscy81NDg5NzIwND9vcHNfcmVxdWVzdF9taXNjPSUyNTdCJTI1MjJyZXF1ZXN0JTI1NUZpZCUyNTIyJTI1M0ElMjUyMjE2MTUwODM4MzkxNjc4MDI2NjI1MzAxMiUyNTIyJTI1MkMlMjUyMnNjbSUyNTIyJTI1M0ElMjUyMjIwMTQwNzEzLjEzMDEwMjMzNC5wYyUyNTVGYWxsLiUyNTIyJTI1N0QmYW1wO3JlcXVlc3RfaWQ9MTYxNTA4MzgzOTE2NzgwMjY2MjUzMDEyJmFtcDtiaXpfaWQ9MCZhbXA7dXRtX21lZGl1bT1kaXN0cmlidXRlLnBjX3NlYXJjaF9yZXN1bHQubm9uZS10YXNrLWJsb2ctMn5hbGx+Zmlyc3RfcmFua192Mn5ob3RfcmFuay00LTU0ODk3MjA0LnBjX3NlYXJjaF9yZXN1bHRfYmVmb3JlX2pzJmFtcDt1dG1fdGVybT1jJUU1JThBJUE4JUU2JTgwJTgxJUU1JTg2JTg1JUU1JUFEJTk4JUU1JTg4JTg2JUU5JTg1JThE\">https://blog.csdn.net/qq_29924041/article/details/54897204?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161508383916780266253012%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161508383916780266253012&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-4-54897204.pc_search_result_before_js&amp;utm_term=c%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D</span></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/03/03/static/",
            "url": "http://example.com/2021/03/03/static/",
            "title": "C中static的运用",
            "date_published": "2021-03-03T11:57:00.150Z",
            "content_html": "<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h5 id=\"1-局部变量\"><a href=\"#1-局部变量\" class=\"headerlink\" title=\"1.局部变量\"></a>1.局部变量</h5><p>定义在函数内部的变量（不加static修饰）属于这个范畴。编译器一般不对普通局部变量进行初始化，也就是说它的值在初始时是不确定的，除非对其显式赋值（啥意思？）。</p>\n<blockquote>\n<p>普通局部变量存储于进程栈空间，使用完毕会立即释放。</p>\n</blockquote>\n<p>静态局部变量使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。</p>\n<p>小程序试一试（大一上期末考过类似的）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......自己臆想吧</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n=<span class=\"number\">10</span></span><br><span class=\"line\">n++=<span class=\"number\">11</span></span><br><span class=\"line\">--------------------</span><br><span class=\"line\"><span class=\"keyword\">static</span> n=<span class=\"number\">10</span></span><br><span class=\"line\">n++=<span class=\"number\">11</span></span><br><span class=\"line\">--------------------</span><br><span class=\"line\">n=<span class=\"number\">10</span></span><br><span class=\"line\">n++=<span class=\"number\">11</span></span><br><span class=\"line\">--------------------</span><br><span class=\"line\"><span class=\"keyword\">static</span> n=<span class=\"number\">11</span></span><br><span class=\"line\">n++=<span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n\n<p>由此可见，静态局部变量的效果跟全局变量有得一拼，而且位于函数体内部，就有利于程序的模块化了。</p>\n<h5 id=\"2-全局变量\"><a href=\"#2-全局变量\" class=\"headerlink\" title=\"2.全局变量\"></a>2.全局变量</h5><p>全局变量定义在函数体外部，在全局数据区分配存储空间，且编译器会自动对其初始化。</p>\n<p>普通全局变量对整个工程可见，其他文件可以使用<strong>extern</strong>外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量）。</p>\n<p>静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。</p>\n<blockquote>\n<p>在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。</p>\n</blockquote>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数。其特性如下： </p>\n<ul>\n<li>静态函数只能在声明它的文件中可见，其他文件不能引用该函数</li>\n<li>不同的文件可以使用相同名字的静态函数，互不影响</li>\n</ul>\n<blockquote>\n<p><em><strong>非</strong></em>静态函数可以在另一个文件中直接引用，甚至不必使用extern声明</p>\n</blockquote>\n<p>非静态函数可以在另一个文件中直接引用，甚至不必使用extern声明： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* file1.c */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello from fun.\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    fun();</span><br><span class=\"line\">    fun1();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* file2.c */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello from static fun1.\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>gcc file1.c file2.c</code>编译时，错误报告如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/tmp/cc2VMzGR.o：在函数‘main’中： </span><br><span class=\"line\">static_fun.c:(.text+<span class=\"number\">0x20</span>)：对‘fun1’未定义的引用</span><br><span class=\"line\">collect2: error: ld returned <span class=\"number\">1</span> <span class=\"built_in\">exit</span> status</span><br></pre></td></tr></table></figure>\n\n<p>修改文件，不使用static修饰符，可在另一文件中引用该函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* file1.c */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello from fun.\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* file2.c */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    fun();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同样使用 <code>gcc file1.c file2.c</code>编译，编译通过，运行结果如下： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; % ./a.out </span><br><span class=\"line\">hello from fun.</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>写下来感觉static还是很有用的（虽然我没用过），能够将代码模块化，达到所谓的松耦合。</p>\n",
            "tags": []
        }
    ]
}